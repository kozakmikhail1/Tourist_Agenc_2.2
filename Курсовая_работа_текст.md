ВВЕДЕНИЕ

В современном мире туризм является одной из наиболее динамично развивающихся отраслей экономики. С ростом мобильности населения и расширением возможностей для путешествий растет и потребность в эффективных системах управления туристическими услугами. Туристические агентства ежедневно обрабатывают большое количество запросов от клиентов, управляют информацией о странах, отелях, транспортных компаниях, формируют туры и обрабатывают заказы. Ручное ведение таких процессов не только трудоемко, но и подвержено ошибкам, что может привести к неудовлетворенности клиентов и финансовым потерям.

Разработка автоматизированной системы управления туристическим агентством призвана решить эти проблемы, предлагая комплексное решение для управления всеми аспектами деятельности агентства. Система должна обеспечивать эффективное управление базой данных о странах, отелях, транспортных компаниях, формирование туристических пакетов с автоматическим расчетом стоимости, а также обработку заказов клиентов. Это позволит сотрудникам агентства сосредоточиться на работе с клиентами, а не на рутинных операциях с данными.

Анализ существующих решений на рынке показывает наличие множества программных продуктов для управления туристическими агентствами. Эти системы варьируются от простых приложений для учета клиентов до сложных ERP-систем, включающих интеграцию с глобальными системами бронирования (GDS). Однако многие из существующих решений либо слишком сложны и дороги для небольших агентств, либо не покрывают все необходимые функции, что создает потребность в разработке специализированного решения.

Разрабатываемый проект представляет собой настольное приложение для управления туристическим агентством, которое поможет автоматизировать процессы управления странами, отелями, транспортными компаниями, турами и заказами. Система будет включать функции категоризации стран по континентам, управления отелями с указанием количества номеров и их характеристик, управления транспортными компаниями с расписанием рейсов, формирования туров с автоматическим расчетом стоимости на основе выбранных услуг, а также управления заказами клиентов с отслеживанием их статуса.

1 ОБЗОР ЛИТЕРАТУРЫ

1.1 Система управления туристическим агентством как проект

Программное обеспечение для управления туристическим агентством включает несколько ключевых компонентов: клиентская часть с графическим интерфейсом, система хранения данных и бизнес-логика для обработки операций. В рамках данного проекта планируется реализация настольного приложения, которое будет работать с локальным хранилищем данных без использования серверной части. Клиентская часть выполняет следующие функции:

‒ Управление базой данных стран: добавление, редактирование и удаление информации о странах, включая континент, столицу и валюту.

‒ Управление базой данных отелей: ведение информации об отелях, их местоположении, категории (количество звезд), адресе и доступных номерах с характеристиками.

‒ Управление транспортными компаниями: ведение информации о компаниях, типе транспорта (самолет, поезд, автобус, корабль) и расписании рейсов с указанием городов отправления и прибытия, дат и стоимости.

‒ Формирование туров: создание туристических пакетов, включающих выбор страны, отеля, транспортной компании и дат поездки с автоматическим расчетом стоимости на основе выбранных услуг.

‒ Управление заказами: обработка заказов клиентов, включая регистрацию персональных данных клиента, выбор тура, расчет общей стоимости и отслеживание статуса заказа (в обработке, подтвержден, оплачен, завершен, отменен).

‒ Поиск туров: предоставление функционала для поиска туров по различным критериям, таким как страна, стоимость и продолжительность.

Для хранения данных используется файловая система с текстовыми файлами в структурированном формате, что позволяет эффективно управлять информацией о всех сущностях системы на локальном компьютере без необходимости подключения к удаленной базе данных.

1.2 Анализ существующих аналогов

На рынке программного обеспечения для туристических агентств существует множество решений, предназначенных как для крупных туроператоров, так и для небольших агентств. Рассмотрим несколько популярных систем, которые могут служить аналогами в контексте управления туристическим агентством.

1.2.1 TravelWorks

TravelWorks — это комплексная система управления туристическим агентством, используемая многими агентствами в России и странах СНГ. Система предоставляет функционал для управления клиентами, турами, заказами и финансовыми операциями. Программа интегрируется с системами бронирования и позволяет автоматизировать многие процессы в работе агентства.

Основные функции:

‒ Управление базой данных клиентов и заказов.

‒ Формирование туров и расчет стоимости.

‒ Интеграция с системами бронирования отелей и транспорта.

‒ Генерация отчетов и документов.

‒ Управление финансами и оплатой.

Преимущества:

‒ Широкая функциональность, покрывающая все аспекты работы агентства.

‒ Интеграция с внешними системами бронирования.

‒ Поддержка работы с документами и отчетностью.

Недостатки:

‒ Высокая стоимость лицензии и сложность настройки.

‒ Требует обучения сотрудников и значительных ресурсов для внедрения.

‒ Избыточный функционал для небольших агентств.

1.2.2 TourOperator

TourOperator — это специализированная система для управления туристическими агентствами, разработанная для автоматизации процессов продажи туров и работы с клиентами. Система предоставляет базовые функции для управления турами, заказами и клиентской базой. Программа может работать в локальном режиме и не требует постоянного подключения к интернету для базовых операций.

Основные функции:

‒ Управление каталогом туров.

‒ Обработка заказов клиентов.

‒ Ведение базы данных клиентов.

‒ Расчет стоимости туров.

‒ Генерация документов для клиентов.

Преимущества:

‒ Простота использования и интуитивно понятный интерфейс.

‒ Возможность работы в оффлайн-режиме.

‒ Доступная стоимость для небольших агентств.

Недостатки:

‒ Ограниченный функционал по сравнению с более сложными системами.

‒ Отсутствие интеграции с системами бронирования.

‒ Ограниченные возможности масштабирования.

1.2.3 Amadeus Selling Platform

Amadeus Selling Platform — это профессиональная система управления туристическим агентством, используемая крупными туроператорами и агентствами по всему миру. Система предоставляет доступ к глобальной системе бронирования Amadeus и включает функционал для управления заказами, клиентами и финансовыми операциями. Программа работает в онлайн-режиме и требует подключения к серверу Amadeus.

Основные функции:

‒ Интеграция с глобальной системой бронирования Amadeus.

‒ Управление заказами и бронированиями.

‒ Работа с клиентской базой.

‒ Финансовое управление и отчетность.

‒ Доступ к актуальной информации о турах, отелях и транспорте.

Преимущества:

‒ Доступ к актуальной информации о турах и услугах в режиме реального времени.

‒ Интеграция с крупнейшей системой бронирования.

‒ Мощный функционал для крупных агентств.

Недостатки:

‒ Очень высокая стоимость лицензии и абонентской платы.

‒ Требует постоянного подключения к интернету.

‒ Сложность настройки и обучения персонала.

‒ Не подходит для небольших агентств из-за высокой стоимости.

1.3 Используемые технологии

Для реализации проекта будут использованы следующие технологии и инструменты:

C++ — язык программирования, который будет использоваться для реализации всей бизнес-логики системы управления туристическим агентством. C++ обеспечивает высокую производительность при работе с большими объемами данных и позволяет эффективно реализовать объектно-ориентированную архитектуру приложения. Язык поддерживает такие концепции, как наследование, полиморфизм, шаблоны и перегрузку операторов, что необходимо для создания гибкой и расширяемой системы.

Qt — кроссплатформенный фреймворк для создания графического пользовательского интерфейса. Qt предоставляет богатый набор виджетов для создания интуитивно понятного интерфейса, включая таблицы для отображения данных, диалоговые окна для ввода информации, меню и панели инструментов. Фреймворк также обеспечивает удобную работу с файлами, что необходимо для хранения данных в текстовом формате. Qt поддерживает сигналы и слоты для реализации событийно-ориентированного программирования, что упрощает создание интерактивного интерфейса.

Объектно-ориентированное программирование — подход к программированию, основанный на концепциях классов и объектов. В рамках проекта будет реализована иерархия классов для представления туристических услуг: базовый класс TouristService, от которого наследуются классы Country, Hotel, TransportCompany и Tour. Это позволит реализовать полиморфизм и обеспечить единообразную работу с различными типами услуг. Класс Order будет представлять заказ клиента и связывать его с выбранным туром.

Шаблоны и контейнеры — для управления коллекциями объектов будут использованы шаблонные классы и STL-контейнеры. Будет реализован собственный шаблонный контейнер DataContainer, который обеспечит типобезопасное хранение и управление объектами различных типов (Country, Hotel, TransportCompany, Tour, Order). Контейнер будет поддерживать итераторы для удобного обхода элементов и использования STL-алгоритмов.

Файловая система — для хранения данных будет использована файловая система с текстовыми файлами в структурированном формате. Каждый тип сущностей (страны, отели, транспортные компании, туры, заказы) будет храниться в отдельном файле. Для работы с файлами будет реализован класс FileManager, который обеспечит загрузку данных из файлов при запуске приложения и сохранение изменений при выходе. Такой подход обеспечивает простоту реализации и возможность ручного редактирования данных при необходимости.

1.4 Постановка задачи

Целью работы является создание настольного приложения для управления туристическим агентством с функциями управления странами, отелями, транспортными компаниями, турами и заказами. Программа будет иметь графический интерфейс, разработанный с использованием Qt, и систему хранения данных на основе текстовых файлов для управления информацией о всех сущностях системы.

Задачи, которые необходимо реализовать:

Управление странами:

‒ Добавление, редактирование и удаление информации о странах.

‒ Хранение информации о стране: название, континент, столица, валюта.

‒ Просмотр списка стран с возможностью сортировки и фильтрации.

Управление отелями:

‒ Добавление, редактирование и удаление информации об отелях.

‒ Хранение информации об отеле: название, страна, категория (количество звезд), адрес.

‒ Управление номерами в отеле: добавление номеров с указанием типа, вместимости и стоимости за ночь.

‒ Просмотр списка отелей с отображением количества доступных номеров.

Управление транспортными компаниями:

‒ Добавление, редактирование и удаление информации о транспортных компаниях.

‒ Хранение информации о компании: название, тип транспорта (самолет, поезд, автобус, корабль).

‒ Управление расписанием рейсов: добавление рейсов с указанием городов отправления и прибытия, дат, стоимости и количества доступных мест.

‒ Просмотр списка транспортных компаний с информацией о количестве рейсов.

Формирование туров:

‒ Создание туров на основе выбранной страны, отеля, транспортной компании и дат поездки.

‒ Автоматический расчет стоимости тура на основе стоимости транспорта и стоимости проживания в отеле (цена за ночь × количество ночей).

‒ Связывание туров с отелями и транспортными компаниями для обеспечения целостности данных.

‒ Просмотр списка туров с информацией о стране, датах и стоимости.

Управление заказами:

‒ Создание заказов на основе выбранного тура и данных клиента (имя, телефон).

‒ Автоматический расчет общей стоимости заказа на основе стоимости выбранного тура.

‒ Отслеживание статуса заказа (в обработке, подтвержден, оплачен, завершен, отменен).

‒ Изменение статуса заказа в процессе обработки.

‒ Просмотр списка заказов с информацией о клиенте, туре, стоимости и статусе.

Поиск туров:

‒ Реализация функционала поиска туров по различным критериям.

‒ Поиск по стране: фильтрация туров по выбранной стране или исключение определенных стран.

‒ Поиск по стоимости: фильтрация туров по максимальной стоимости.

‒ Поиск по продолжительности: фильтрация туров по минимальной продолжительности.

‒ Комбинированный поиск с применением нескольких критериев одновременно.

Хранение данных:

‒ Использование текстовых файлов для хранения информации о странах, отелях, транспортных компаниях, турах и заказах.

‒ Реализация загрузки данных из файлов при запуске приложения.

‒ Реализация сохранения данных в файлы при закрытии приложения или по запросу пользователя.

‒ Обеспечение целостности данных при выполнении операций.

Интерфейс пользователя:

‒ Создание графического интерфейса с использованием Qt с вкладками для различных типов сущностей (Страны, Отели, Транспортные компании, Туры, Заказы).

‒ Реализация таблиц для отображения списков сущностей с возможностью сортировки по различным столбцам.

‒ Создание диалоговых окон для добавления и редактирования сущностей.

‒ Реализация контекстных меню и кнопок для выполнения операций (добавить, редактировать, удалить).

‒ Обеспечение интуитивно понятного и удобного интерфейса для работы с системой.

Программа должна обеспечивать выполнение всех основных функций системы управления туристическим агентством с возможностью управления всеми типами сущностей, формирования туров с автоматическим расчетом стоимости и обработки заказов клиентов.

2 ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ

Проект включает в себя несколько ключевых функций, которые обеспечат эффективное управление туристическим агентством, автоматизацию процессов формирования туров и обработки заказов. Основные возможности включают в себя:

Возможность управления базой данных стран, отелей и транспортных компаний с добавлением, редактированием и удалением записей.

Функция формирования туров с автоматическим расчетом стоимости на основе выбранных услуг (отель, транспорт) и дат поездки. Все рейсы отправляются из Минска (Беларусь).

Автоматическое связывание туров с отелями и транспортными компаниями на основе страны назначения и дат поездки для обеспечения целостности данных.

Функции для создания и обработки заказов клиентов с отслеживанием статуса заказа и автоматическим расчетом общей стоимости.

Возможность поиска туров по различным критериям (страна, стоимость, продолжительность) с применением фильтров и исключений.

Сохранение и загрузка данных о всех сущностях системы в текстовых файлах с обеспечением целостности данных при выполнении операций.

Использование объектно-ориентированного подхода с иерархией классов для представления туристических услуг и обеспечения полиморфизма при работе с различными типами данных.

Для более детального понимания архитектуры проекта используется диаграмма классов (Приложение А), которая визуализирует структуру системы и взаимосвязи между основными компонентами. Эта диаграмма помогает увидеть, как данные перемещаются через систему, как различные классы взаимодействуют друг с другом, и как реализована иерархия наследования для туристических услуг.

2.1 Описание функции формирования тура с автоматическим расчетом стоимости

Функция формирования тура является одной из ключевых функций системы, позволяющей создавать туристические пакеты на основе выбранных услуг и автоматически рассчитывать их стоимость. Эта функция разработана с учетом необходимости обеспечения корректности данных, валидации входных параметров и автоматического вычисления итоговой стоимости тура.

Процесс формирования тура начинается с выбора пользователем базовых параметров: названия тура, страны назначения, дат начала и окончания поездки. Система проверяет корректность введенных данных, включая валидность дат (дата окончания должна быть позже даты начала) и наличие выбранной страны в базе данных. Если какой-либо параметр не проходит проверку, процесс формирования тура останавливается с генерацией соответствующего сообщения об ошибке.

После успешной проверки базовых параметров пользователь выбирает отель из списка доступных отелей в выбранной стране. Система автоматически фильтрует список отелей, отображая только те, которые расположены в выбранной стране. При выборе отеля пользователь также выбирает конкретный номер из доступных номеров отеля, каждый из которых имеет свой тип (одноместный, двухместный, люкс и т.д.), вместимость и стоимость за ночь.

Далее пользователь выбирает транспортную компанию и конкретный рейс из расписания. Система также автоматически фильтрует транспортные компании, отображая только те, которые имеют рейсы в города выбранной страны. При фильтрации учитываются столица страны, города из адресов отелей, а также известные туристические города (например, для ОАЭ учитываются как столица Абу-Даби, так и Дубай). Система проверяет, чтобы дата рейса была не позже даты начала тура.

После выбора всех компонентов тура система автоматически рассчитывает его стоимость. Расчет выполняется по следующей формуле: стоимость тура = стоимость транспорта + (стоимость номера за ночь × количество ночей). Количество ночей вычисляется как разница между датой окончания и датой начала тура. Стоимость транспорта берется из выбранного рейса, а стоимость проживания рассчитывается на основе выбранного номера в отеле и продолжительности тура.

Особенностью реализации является использование виртуальной функции calculateCost() из базового класса TouristService, которая переопределена в классе Tour. Это обеспечивает полиморфизм и позволяет единообразно работать с различными типами туристических услуг. Расчет стоимости выполняется динамически при каждом обращении, что гарантирует актуальность данных даже при изменении цен на услуги.

После формирования тура система автоматически связывает его с выбранными отелем и транспортной компанией, сохраняя ссылки на эти объекты внутри объекта тура. Это обеспечивает целостность данных и позволяет в дальнейшем автоматически обновлять информацию о туре при изменении данных об отеле или транспорте.

Данная функция является важным компонентом проекта, обеспечивая автоматизацию процесса создания туров и исключая возможность ошибок при ручном расчете стоимости. Она позволяет сотрудникам агентства быстро формировать туристические пакеты и предоставлять клиентам точную информацию о стоимости поездки.

2.2 Описание функции управления заказами

Функция управления заказами отвечает за создание, обработку и отслеживание заказов клиентов в системе. Она выполняет несколько ключевых операций для обеспечения корректного процесса работы с заказами от момента их создания до завершения.

Процесс создания заказа начинается с выбора тура из списка доступных туров или формирования нового тура непосредственно при создании заказа. Система проверяет наличие выбранного тура в базе данных и его валидность (наличие названия, страны, корректных дат). Если тур не найден или содержит некорректные данные, процесс создания заказа останавливается с указанием причины.

После выбора тура пользователь вводит данные клиента: имя и контактный телефон. Система проверяет, что обязательные поля заполнены и не пусты. Если какое-либо поле не проходит проверку, создание заказа блокируется. Это позволяет избежать создания заказов с неполными данными, что может привести к проблемам при дальнейшей работе с клиентом.

После успешной проверки данных создается новый объект заказа, которому автоматически присваивается уникальный идентификатор. Идентификатор генерируется автоматически с использованием статической переменной, что гарантирует его уникальность. Заказу присваивается начальный статус "В обработке", а дата создания заказа устанавливается как текущая дата и время.

Одной из ключевых особенностей функции является автоматический расчет общей стоимости заказа на основе стоимости выбранного тура. Расчет выполняется через вызов метода calculateCost() объекта тура, что обеспечивает актуальность стоимости даже при изменении данных о туре. Если тур в заказе не имеет связанных отеля и транспортной компании, система автоматически пытается связать их на основе страны тура и дат поездки, используя функцию linkOrdersToursWithHotelsAndTransport().

Функция обработки заказа позволяет изменять статус заказа в процессе его обработки. Доступны следующие статусы: "В обработке", "Подтвержден", "Оплачен", "Завершен", "Отменен". При изменении статуса система проверяет, что новый статус отличается от текущего, и обновляет информацию о заказе. Это позволяет отслеживать жизненный цикл заказа от момента создания до завершения или отмены.

Функция редактирования заказа позволяет изменять данные клиента (имя, телефон) и выбранный тур. При изменении тура система автоматически пересчитывает стоимость заказа и обновляет связи тура с отелями и транспортом. Это обеспечивает актуальность данных заказа даже при изменении его параметров.

Все операции с заказами выполняются с проверкой целостности данных. При удалении заказа система проверяет его существование и запрашивает подтверждение у пользователя. При отображении заказов в таблице система фильтрует заказы с пустыми данными (отсутствие названия тура, имени клиента или телефона), что обеспечивает отображение только валидных записей.

Таким образом, функция управления заказами предоставляет комплексный инструмент для работы с заказами клиентов, объединяя создание, обработку, отслеживание статуса и обеспечение целостности данных. Она является неотъемлемой частью системы управления туристическим агентством, повышая эффективность работы с клиентами и обеспечивая прозрачность процессов.

2.3 Описание функции поиска туров

Функция поиска туров предназначена для предоставления пользователям возможности находить туры, соответствующие заданным критериям. Эта функция реализована с использованием STL-алгоритмов и обеспечивает гибкую фильтрацию туров по различным параметрам с возможностью комбинирования нескольких критериев.

Процесс поиска начинается с получения критериев фильтрации от пользователя. Система поддерживает три основных критерия поиска: по стране, по максимальной стоимости и по минимальной продолжительности. Для каждого критерия пользователь может выбрать одно из трех состояний: "Не применять" (критерий игнорируется), "Фильтровать" (включать только туры, соответствующие критерию) или "Исключить" (исключать туры, соответствующие критерию).

Фильтр по стране работает на основе текстового поиска с учетом регистра. Пользователь вводит название страны или его часть, и система проверяет, содержится ли эта строка в названии страны тура. При выборе режима "Фильтровать" в результаты поиска попадают только туры, страна которых содержит введенный текст. При выборе режима "Исключить" из результатов исключаются туры, страна которых содержит указанный текст. Это позволяет, например, найти все туры в Европу, исключив определенные страны.

Фильтр по стоимости работает на основе максимального значения. Пользователь указывает максимальную стоимость тура, и система сравнивает рассчитанную стоимость каждого тура с этим значением. При режиме "Фильтровать" в результаты попадают только туры со стоимостью, не превышающей указанное значение. При режиме "Исключить" из результатов исключаются туры со стоимостью, не превышающей указанное значение, что позволяет найти более дорогие туры.

Фильтр по продолжительности работает на основе минимального количества дней. Система вычисляет продолжительность каждого тура как разницу между датой окончания и датой начала поездки. При режиме "Фильтровать" в результаты попадают только туры с продолжительностью, не меньшей указанного значения. При режиме "Исключить" из результатов исключаются туры с продолжительностью, не меньшей указанного значения.

Особенностью реализации является использование STL-алгоритма std::copy_if для фильтрации туров. Алгоритм применяет предикат (лямбда-функцию) к каждому туру в контейнере и копирует в результирующий контейнер только те туры, для которых предикат возвращает true. Предикат проверяет все три критерия фильтрации последовательно, применяя логику каждого критерия в зависимости от его состояния. Это обеспечивает эффективную фильтрацию больших объемов данных.

После фильтрации результаты автоматически сортируются по стоимости по возрастанию с использованием STL-алгоритма std::sort. Это позволяет пользователю видеть наиболее доступные туры в начале списка. Сортировка выполняется на основе вычисленной стоимости тура через метод calculateCost().

Результаты поиска отображаются в таблице, которая показывает название тура, страну, даты начала и окончания, а также стоимость. Для правильной числовой сортировки стоимости используется специальный класс NumericSortItem, который хранит числовое значение отдельно от текстового представления, что обеспечивает корректную сортировку по числовому значению, а не по алфавиту.

Функция также обеспечивает валидацию входных данных. Проверяется корректность введенных значений (например, стоимость не может быть отрицательной, продолжительность должна быть положительным числом). Если обнаруживаются некорректные данные, система отображает соответствующее сообщение, но не прерывает процесс поиска, применяя только валидные критерии.

Таким образом, функция поиска туров предоставляет мощный и гибкий инструмент для нахождения туров, соответствующих требованиям пользователя. Она объединяет фильтрацию по нескольким критериям, автоматическую сортировку результатов и удобное отображение информации, что делает процесс поиска туров быстрым и эффективным.

2.4 Описание функции связывания туров с отелями и транспортными компаниями

Функция связывания туров с отелями и транспортными компаниями обеспечивает автоматическое установление связей между турами и соответствующими услугами на основе страны назначения и дат поездки. Эта функция является важным компонентом системы, обеспечивающим целостность данных и корректность расчета стоимости туров.

Процесс связывания начинается с перебора всех туров в системе. Для каждого тура система извлекает информацию о стране назначения и дате начала поездки. На основе страны тура система определяет столицу страны, используя данные из базы стран. Столица используется как один из целевых городов для поиска подходящих рейсов.

Далее система собирает все возможные целевые города для поиска транспорта. В этот набор включаются столица страны, города из адресов отелей, расположенных в выбранной стране, а также известные туристические города (например, для ОАЭ учитываются как столица Абу-Даби, так и Дубай). Это обеспечивает гибкость при поиске подходящих рейсов, так как рейсы могут прибывать в различные города страны.

Для каждого тура система ищет подходящий отель среди отелей, расположенных в стране тура. Отель считается подходящим, если он находится в той же стране, что и тур, и имеет хотя бы один доступный номер. При нахождении подходящего отеля система связывает его с туром, сохраняя объект отеля внутри объекта тура.

После связывания отеля система ищет подходящий рейс среди всех транспортных компаний. Для каждой транспортной компании система перебирает все рейсы в ее расписании. Рейс считается подходящим, если город прибытия совпадает с одним из целевых городов (с учетом частичного совпадения и без учета регистра), а дата отправления рейса не позже даты начала тура. Система проверяет как точное совпадение городов, так и частичное (например, если рейс прибывает в "Дубай", а целевой город "Дубай-Маррина"), что повышает вероятность нахождения подходящего рейса.

Особенностью реализации является использование множества (QSet) для хранения целевых городов, что обеспечивает быстрый поиск и исключает дубликаты. При проверке совпадения городов система использует сравнение без учета регистра и проверяет как точное совпадение, так и вхождение одной строки в другую, что позволяет находить рейсы даже при незначительных различиях в написании названий городов.

После нахождения подходящего рейса система связывает его с туром, сохраняя как объект транспортной компании, так и объект расписания рейса внутри объекта тура. Это позволяет в дальнейшем использовать эту информацию для расчета стоимости тура и отображения детальной информации о транспорте.

Функция также обрабатывает специальные случаи. Например, для стран с несколькими популярными туристическими городами (таких как ОАЭ) система учитывает все известные города при поиске рейсов. Если у тура отсутствуют валидные даты, система устанавливает даты по умолчанию (текущая дата и дата через неделю), что позволяет корректно рассчитать стоимость даже для туров с неполными данными.

Для заказов реализована дополнительная логика связывания. Система сначала пытается найти полный тур по названию и стране в списке туров. Если такой тур найден, используются его данные, включая связи с отелем и транспортом. Если полный тур не найден, система применяет ту же логику автоматического связывания, что и для обычных туров.

Данная функция вызывается автоматически при загрузке данных из файлов, при создании или редактировании туров и заказов, а также при удалении туров. Это обеспечивает актуальность связей между сущностями и гарантирует, что все туры имеют корректно связанные отели и транспортные компании для правильного расчета стоимости.

Таким образом, функция связывания туров с отелями и транспортными компаниями является важным компонентом системы, обеспечивающим автоматизацию установления связей между сущностями и гарантирующим целостность данных. Она упрощает процесс работы с турами и исключает необходимость ручного связывания услуг, что повышает эффективность работы системы и снижает вероятность ошибок.

3 РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ

3.1 Описание программных модулей

1 Класс: TouristService.

Абстрактный базовый класс для всех туристических услуг. Обеспечивает единый интерфейс для работы с различными типами услуг через механизм виртуальных функций и полиморфизма.

Поля:

‒ name_ (QString): название услуги.

‒ price_ (double): базовая цена услуги.

Методы:

‒ TouristService(const QString& name, double price): конструктор, устанавливающий название и цену услуги.

‒ virtual ~TouristService(): виртуальный деструктор для корректного уничтожения объектов производных классов.

‒ getName() const: возвращает название услуги.

‒ setName(const QString& name): устанавливает название услуги.

‒ getPrice() const: возвращает базовую цену услуги.

‒ setPrice(double price): устанавливает базовую цену услуги.

‒ virtual QString getType() const = 0: чистая виртуальная функция, возвращающая тип услуги. Должна быть реализована в производных классах.

‒ virtual QString getDescription() const = 0: чистая виртуальная функция, возвращающая описание услуги. Должна быть реализована в производных классах.

‒ virtual double calculateCost() const: виртуальная функция расчета стоимости с реализацией по умолчанию, возвращающая базовую цену.

‒ virtual void writeToStream(std::ostream& os) const: виртуальная функция для записи в поток.

‒ virtual void readFromStream(std::istream& is): виртуальная функция для чтения из потока.

2 Класс: Country.

Представляет страну как туристическое направление. Наследуется от TouristService. Хранит информацию о стране: название, континент, столицу и валюту.

Поля:

‒ continent_ (QString): континент, на котором расположена страна.

‒ capital_ (QString): столица страны.

‒ currency_ (QString): валюта страны.

Методы:

‒ Country(const QString& name, const QString& continent): конструктор, устанавливающий название и континент.

‒ QString getType() const override: возвращает тип "Country".

‒ QString getDescription() const override: возвращает описание страны.

‒ QString getContinent() const: возвращает континент.

‒ void setContinent(const QString& continent): устанавливает континент.

‒ QString getCapital() const: возвращает столицу.

‒ void setCapital(const QString& capital): устанавливает столицу.

‒ QString getCurrency() const: возвращает валюту.

‒ void setCurrency(const QString& currency): устанавливает валюту.

‒ bool operator==(const Country& other) const: оператор сравнения на равенство.

‒ bool operator!=(const Country& other) const: оператор сравнения на неравенство.

‒ Country& operator=(const Country& other): оператор присваивания.

‒ friend std::ostream& operator<<(std::ostream& os, const Country& country): дружественная функция для вывода в поток.

‒ friend std::istream& operator>>(std::istream& is, Country& country): дружественная функция для ввода из потока.

‒ void writeToFile(std::ofstream& ofs) const: запись данных страны в файл.

‒ void readFromFile(std::ifstream& ifs): чтение данных страны из файла.

3 Класс: Room.

Представляет номер в отеле. Наследуется от TouristService. Хранит информацию о типе номера, его вместимости и стоимости за ночь.

Поля:

‒ roomType_ (RoomType): тип номера (одноместный, двухместный, люкс, апартаменты).

‒ capacity_ (int): вместимость номера (количество человек).

‒ pricePerNight_ (double): стоимость номера за ночь.

Методы:

‒ Room(const QString& name, RoomType type, double pricePerNight, int capacity): конструктор номера.

‒ QString getType() const override: возвращает тип "Room".

‒ QString getDescription() const override: возвращает описание номера.

‒ RoomType getRoomType() const: возвращает тип номера.

‒ void setRoomType(RoomType type): устанавливает тип номера.

‒ int getCapacity() const: возвращает вместимость номера.

‒ void setCapacity(int capacity): устанавливает вместимость номера.

‒ double getPricePerNight() const: возвращает стоимость за ночь.

‒ void setPricePerNight(double price): устанавливает стоимость за ночь.

‒ static QString roomTypeToString(RoomType type): преобразует тип номера в строку.

‒ static RoomType stringToRoomType(const QString& str): преобразует строку в тип номера.

4 Класс: Hotel.

Представляет отель как туристическую услугу. Наследуется от TouristService. Хранит информацию об отеле: название, страну, категорию (количество звезд), адрес и список номеров.

Поля:

‒ country_ (QString): страна, в которой расположен отель.

‒ stars_ (int): категория отеля (количество звезд).

‒ address_ (QString): адрес отеля.

‒ rooms_ (QVector<Room>): вектор номеров отеля.

Методы:

‒ Hotel(const QString& name, const QString& country, int stars, const QString& address): конструктор отеля.

‒ QString getType() const override: возвращает тип "Hotel".

‒ QString getDescription() const override: возвращает описание отеля.

‒ double calculateCost() const override: переопределенная функция расчета стоимости, суммирует стоимость всех номеров.

‒ QString getCountry() const: возвращает страну отеля.

‒ void setCountry(const QString& country): устанавливает страну отеля.

‒ int getStars() const: возвращает категорию отеля.

‒ void setStars(int stars): устанавливает категорию отеля.

‒ QString getAddress() const: возвращает адрес отеля.

‒ void setAddress(const QString& address): устанавливает адрес отеля.

‒ void addRoom(const Room& room): добавляет номер в отель.

‒ void removeRoom(int index): удаляет номер по индексу.

‒ QVector<Room> getRooms() const: возвращает все номера отеля.

‒ Room* getRoom(int index): возвращает указатель на номер по индексу.

‒ const Room* getRoom(int index) const: возвращает константный указатель на номер по индексу.

‒ int getRoomCount() const: возвращает количество номеров в отеле.

5 Класс: TransportSchedule.

Структура, представляющая расписание рейса транспортной компании. Хранит информацию о городе отправления, городе прибытия, датах отправления и прибытия, стоимости и количестве доступных мест.

Поля:

‒ departureCity (QString): город отправления.

‒ arrivalCity (QString): город прибытия.

‒ departureDate (QDate): дата отправления.

‒ arrivalDate (QDate): дата прибытия.

‒ price (double): стоимость рейса.

‒ availableSeats (int): количество доступных мест.

6 Класс: TransportCompany.

Представляет транспортную компанию как туристическую услугу. Наследуется от TouristService. Хранит информацию о компании: название, тип транспорта (самолет, поезд, автобус, корабль) и расписание рейсов.

Поля:

‒ transportType_ (TransportType): тип транспорта.

‒ schedules_ (QVector<TransportSchedule>): вектор расписаний рейсов.

Методы:

‒ TransportCompany(const QString& name, TransportType type): конструктор транспортной компании.

‒ QString getType() const override: возвращает тип "TransportCompany".

‒ QString getDescription() const override: возвращает описание транспортной компании.

‒ TransportType getTransportType() const: возвращает тип транспорта.

‒ void setTransportType(TransportType type): устанавливает тип транспорта.

‒ void addSchedule(const TransportSchedule& schedule): добавляет рейс в расписание.

‒ void removeSchedule(int index): удаляет рейс по индексу.

‒ QVector<TransportSchedule> getSchedules() const: возвращает все расписания рейсов.

‒ TransportSchedule* getSchedule(int index): возвращает указатель на расписание по индексу.

‒ int getScheduleCount() const: возвращает количество рейсов в расписании.

‒ static QString transportTypeToString(TransportType type): преобразует тип транспорта в строку.

‒ static TransportType stringToTransportType(const QString& str): преобразует строку в тип транспорта.

7 Класс: Tour.

Представляет тур как комплексную туристическую услугу. Наследуется от TouristService. Хранит информацию о туре: название, страну назначения, даты начала и окончания, связанный отель, транспортную компанию и расписание рейса. Хранит объекты Hotel и TransportCompany по значению, что обеспечивает целостность данных тура даже при изменении исходных объектов.

Поля:

‒ country_ (QString): страна назначения тура.

‒ startDate_ (QDate): дата начала тура.

‒ endDate_ (QDate): дата окончания тура.

‒ hotel_ (Hotel): отель, связанный с туром (хранится по значению).

‒ transportCompany_ (TransportCompany): транспортная компания, связанная с туром (хранится по значению).

‒ transportSchedule_ (TransportSchedule): расписание рейса для тура.

Методы:

‒ Tour(const QString& name, const QString& country, const QDate& startDate, const QDate& endDate): конструктор тура.

‒ QString getType() const override: возвращает тип "Tour".

‒ QString getDescription() const override: возвращает описание тура.

‒ double calculateCost() const override: переопределенная функция расчета стоимости тура на основе стоимости транспорта и стоимости проживания в отеле.

‒ QString getCountry() const: возвращает страну назначения.

‒ void setCountry(const QString& country): устанавливает страну назначения.

‒ QDate getStartDate() const: возвращает дату начала тура.

‒ void setStartDate(const QDate& date): устанавливает дату начала тура.

‒ QDate getEndDate() const: возвращает дату окончания тура.

‒ void setEndDate(const QDate& date): устанавливает дату окончания тура.

‒ int getDuration() const: возвращает продолжительность тура в днях.

‒ void setHotel(const Hotel& hotel): устанавливает отель для тура (копирует объект).

‒ Hotel getHotel() const: возвращает копию отеля тура.

‒ Hotel* getHotelPtr(): возвращает указатель на отель тура для модификации.

‒ void setTransportCompany(const TransportCompany& company): устанавливает транспортную компанию для тура (копирует объект).

‒ TransportCompany getTransportCompany() const: возвращает копию транспортной компании тура.

‒ TransportCompany* getTransportCompanyPtr(): возвращает указатель на транспортную компанию тура для модификации.

‒ void setTransportSchedule(const TransportSchedule& schedule): устанавливает расписание рейса для тура.

‒ TransportSchedule getTransportSchedule() const: возвращает расписание рейса для тура.

8 Класс: Order.

Представляет заказ клиента на туристический тур. Хранит информацию о заказе: уникальный идентификатор, связанный тур, данные клиента (имя, телефон), дату создания заказа и статус обработки.

Поля:

‒ nextId_ (static int): статическая переменная для генерации уникальных идентификаторов заказов.

‒ id_ (int): уникальный идентификатор заказа.

‒ tour_ (Tour): тур, на который оформлен заказ.

‒ clientName_ (QString): имя клиента.

‒ clientPhone_ (QString): телефон клиента.

‒ orderDate_ (QDateTime): дата и время создания заказа.

‒ status_ (QString): статус заказа (В обработке, Подтвержден, Оплачен, Завершен, Отменен).

Методы:

‒ Order(): конструктор по умолчанию, создает заказ с автоматически сгенерированным идентификатором.

‒ Order(const Tour& tour, const QString& clientName, const QString& clientPhone): конструктор заказа с параметрами.

‒ int getId() const: возвращает идентификатор заказа.

‒ Tour getTour() const: возвращает тур заказа.

‒ void setTour(const Tour& tour): устанавливает тур для заказа.

‒ QString getClientName() const: возвращает имя клиента.

‒ void setClientName(const QString& name): устанавливает имя клиента.

‒ QString getClientPhone() const: возвращает телефон клиента.

‒ void setClientPhone(const QString& phone): устанавливает телефон клиента.

‒ QDateTime getOrderDate() const: возвращает дату создания заказа.

‒ void setOrderDate(const QDateTime& date): устанавливает дату создания заказа.

‒ double getTotalCost() const: возвращает общую стоимость заказа на основе стоимости тура.

‒ QString getStatus() const: возвращает статус заказа.

‒ void setStatus(const QString& status): устанавливает статус заказа.

‒ QString toString() const: возвращает строковое представление заказа.

‒ bool operator==(const Order& other) const: оператор сравнения на равенство по идентификатору.

‒ bool operator!=(const Order& other) const: оператор сравнения на неравенство.

‒ bool operator<(const Order& other) const: оператор сравнения для сортировки по стоимости.

‒ friend std::ostream& operator<<(std::ostream& os, const Order& order): дружественная функция для вывода в поток.

‒ friend std::istream& operator>>(std::istream& is, Order& order): дружественная функция для ввода из потока.

‒ void writeToFile(std::ofstream& ofs) const: запись данных заказа в файл.

‒ void readFromFile(std::ifstream& ifs): чтение данных заказа из файла.

9 Класс: ContainerIterator.

Шаблонный класс итератора для контейнера DataContainer. Реализует функциональность random access iterator, позволяя использовать STL-алгоритмы для работы с контейнером.

Поля:

‒ ptr_ (typename QVector<T>::iterator): итератор вектора Qt, используемый для доступа к элементам.

Методы:

‒ ContainerIterator(): конструктор по умолчанию.

‒ explicit ContainerIterator(typename QVector<T>::iterator it): конструктор с параметром итератора.

‒ reference operator*() const: оператор разыменования, возвращает ссылку на элемент.

‒ pointer operator->() const: оператор доступа к членам, возвращает указатель на элемент.

‒ ContainerIterator& operator++(): префиксный оператор инкремента.

‒ ContainerIterator operator++(int): постфиксный оператор инкремента.

‒ ContainerIterator& operator--(): префиксный оператор декремента.

‒ ContainerIterator operator--(int): постфиксный оператор декремента.

‒ ContainerIterator& operator+=(difference_type n): оператор добавления смещения.

‒ ContainerIterator& operator-=(difference_type n): оператор вычитания смещения.

‒ ContainerIterator operator+(difference_type n) const: оператор сложения итератора и смещения.

‒ ContainerIterator operator-(difference_type n) const: оператор вычитания смещения из итератора.

‒ difference_type operator-(const ContainerIterator& other) const: оператор вычисления расстояния между итераторами.

‒ bool operator==(const ContainerIterator& other) const: оператор сравнения на равенство.

‒ bool operator!=(const ContainerIterator& other) const: оператор сравнения на неравенство.

‒ bool operator<(const ContainerIterator& other) const: оператор сравнения "меньше".

‒ bool operator>(const ContainerIterator& other) const: оператор сравнения "больше".

‒ bool operator<=(const ContainerIterator& other) const: оператор сравнения "меньше или равно".

‒ bool operator>=(const ContainerIterator& other) const: оператор сравнения "больше или равно".

10 Класс: DataContainer.

Шаблонный контейнер для хранения данных различных типов. Обеспечивает типобезопасное хранение и управление объектами. Использует QVector для внутреннего хранения и предоставляет итераторы для использования STL-алгоритмов.

Поля:

‒ data_ (QVector<T>): вектор Qt для хранения элементов контейнера.

Методы:

‒ DataContainer(): конструктор по умолчанию.

‒ ~DataContainer(): деструктор.

‒ void add(const T& item): добавляет элемент в контейнер.

‒ void remove(int index): удаляет элемент по индексу.

‒ void remove(const T& item): удаляет элемент по значению.

‒ T* get(int index): возвращает указатель на элемент по индексу.

‒ const T* get(int index) const: возвращает константный указатель на элемент по индексу.

‒ int size() const: возвращает количество элементов в контейнере.

‒ bool isEmpty() const: проверяет, пуст ли контейнер.

‒ void clear(): очищает контейнер.

‒ Iterator begin(): возвращает итератор на начало контейнера.

‒ Iterator end(): возвращает итератор на конец контейнера.

‒ ConstIterator begin() const: возвращает константный итератор на начало контейнера.

‒ ConstIterator end() const: возвращает константный итератор на конец контейнера.

‒ ConstIterator cbegin() const: возвращает константный итератор на начало контейнера.

‒ ConstIterator cend() const: возвращает константный итератор на конец контейнера.

‒ QVector<T>& getData(): возвращает ссылку на внутренний вектор.

‒ const QVector<T>& getData() const: возвращает константную ссылку на внутренний вектор.

‒ template<typename Predicate> Iterator findIf(Predicate pred): находит первый элемент, удовлетворяющий предикату.

‒ template<typename Predicate> ConstIterator findIf(Predicate pred) const: находит первый элемент, удовлетворяющий предикату (константная версия).

‒ template<typename Predicate> bool removeIf(Predicate pred): удаляет первый элемент, удовлетворяющий предикату.

11 Класс: FileManager.

Менеджер для работы с файлами данных. Обеспечивает сохранение и загрузку данных о странах, отелях, транспортных компаниях, турах и заказах в текстовые файлы. Использует кодировку UTF-8 для корректной работы с кириллицей.

Поля:

‒ dataPath_ (QString): путь к директории с данными.

Методы:

‒ FileManager(): конструктор, создающий директорию данных, если она не существует.

‒ void saveCountries(const DataContainer<Country>& countries, const QString& filename) const: сохраняет страны в файл.

‒ void saveHotels(const DataContainer<Hotel>& hotels, const QString& filename) const: сохраняет отели в файл.

‒ void saveTransportCompanies(const DataContainer<TransportCompany>& companies, const QString& filename) const: сохраняет транспортные компании в файл.

‒ void saveTours(const DataContainer<Tour>& tours, const QString& filename) const: сохраняет туры в файл.

‒ void saveOrders(const DataContainer<Order>& orders, const QString& filename) const: сохраняет заказы в файл.

‒ void loadCountries(DataContainer<Country>& countries, const QString& filename) const: загружает страны из файла.

‒ void loadHotels(DataContainer<Hotel>& hotels, const QString& filename) const: загружает отели из файла.

‒ void loadTransportCompanies(DataContainer<TransportCompany>& companies, const QString& filename) const: загружает транспортные компании из файла.

‒ void loadTours(DataContainer<Tour>& tours, const QString& filename) const: загружает туры из файла.

‒ void loadOrders(DataContainer<Order>& orders, const QString& filename) const: загружает заказы из файла.

‒ void saveAll(const DataContainer<Country>& countries, const DataContainer<Hotel>& hotels, const DataContainer<TransportCompany>& companies, const DataContainer<Tour>& tours, const DataContainer<Order>& orders, const QString& basePath) const: сохраняет все данные в файлы.

‒ void loadAll(DataContainer<Country>& countries, DataContainer<Hotel>& hotels, DataContainer<TransportCompany>& companies, DataContainer<Tour>& tours, DataContainer<Order>& orders, const QString& basePath) const: загружает все данные из файлов.

Приватные вспомогательные методы:

‒ void openFileForWriting(QFile& file, const QString& filename) const: открывает файл для записи с обработкой ошибок (принимает ссылку на QFile).

‒ void openFileForReading(QFile& file, const QString& filename) const: открывает файл для чтения с обработкой ошибок (принимает ссылку на QFile).

‒ void validateFileHeader(QTextStream& in, const QString& expectedHeader) const: проверяет заголовок файла при загрузке данных.

‒ void saveHotelToStream(QTextStream& out, const Hotel& hotel) const: сохранение отеля в поток.

‒ void saveRoomToStream(QTextStream& out, const Room& room) const: сохранение номера в поток.

‒ void saveTransportCompanyToStream(QTextStream& out, const TransportCompany& company) const: сохранение транспортной компании в поток.

‒ void saveScheduleToStream(QTextStream& out, const TransportSchedule& schedule) const: сохранение расписания в поток.

‒ Hotel loadHotelFromStream(QTextStream& in) const: загрузка отеля из потока.

‒ Room loadRoomFromStream(QTextStream& in) const: загрузка номера из потока.

‒ TransportCompany loadTransportCompanyFromStream(QTextStream& in) const: загрузка транспортной компании из потока.

‒ TransportSchedule loadScheduleFromStream(QTextStream& in) const: загрузка расписания из потока.

‒ Room readRoomFromStream(QTextStream& in, const QString& hotelName, int hotelIndex, int roomIndex) const: чтение номера из потока с обработкой ошибок.

‒ void skipInvalidHotelLines(QTextStream& in, int linesToSkip) const: пропуск невалидных строк при загрузке отеля.

‒ QString determineOrderStatus(QTextStream& in, int orderIndex, int totalOrders) const: определение статуса заказа при загрузке.

12 Класс: FileException.

Исключение, возникающее при ошибке работы с файлами. Наследуется от std::exception.

Методы:

‒ FileException(const QString& message): конструктор, принимающий сообщение об ошибке.

‒ const char* what() const noexcept override: возвращает сообщение об ошибке.

13 Класс: StreamFileManager.

Менеджер для работы с файлами через стандартные потоки C++. Обеспечивает альтернативный способ сохранения и загрузки данных о странах и заказах с использованием потоков std::ifstream и std::ofstream. Демонстрирует работу с файловыми потоками и перегрузку операторов ввода/вывода.

Поля:

‒ basePath_ (std::string): путь к директории с данными.

Методы:

‒ StreamFileManager(const std::string& basePath): конструктор, принимающий базовый путь к данным.

‒ void saveCountries(const DataContainer<Country>& countries, const std::string& filename) const: сохраняет страны в файл через потоки.

‒ void saveOrders(const DataContainer<Order>& orders, const std::string& filename) const: сохраняет заказы в файл через потоки.

‒ void loadCountries(DataContainer<Country>& countries, const std::string& filename) const: загружает страны из файла через потоки.

‒ void loadOrders(DataContainer<Order>& orders, const std::string& filename) const: загружает заказы из файла через потоки.

‒ void saveAll(const DataContainer<Country>& countries, const DataContainer<Order>& orders, const std::string& basePath) const: сохраняет все данные через потоки.

‒ void loadAll(DataContainer<Country>& countries, DataContainer<Order>& orders, const std::string& basePath) const: загружает все данные через потоки.

‒ void ensureDirectoryExists(const std::string& path) const: вспомогательный метод для создания директории, если она не существует.

14 Класс: StreamFileException.

Исключение, возникающее при ошибке работы с файлами через потоки. Наследуется от std::exception.

Методы:

‒ StreamFileException(const std::string& message): конструктор, принимающий сообщение об ошибке.

‒ const char* what() const noexcept override: возвращает сообщение об ошибке.

15 Класс: NumericSortItem.

Кастомный класс для числовой сортировки в QTableWidget. Хранит числовое значение отдельно от текстового представления, что обеспечивает корректную числовую сортировку, а не алфавитную.

Поля:

‒ numericValue_ (double): числовое значение для сортировки.

Методы:

‒ NumericSortItem(const QString& text, double numericValue): конструктор, принимающий текстовое представление и числовое значение.

‒ bool operator<(const QTableWidgetItem& other) const override: переопределенный оператор сравнения для числовой сортировки.

‒ QVariant data(int role) const override: переопределенная функция для возврата данных, включая числовое значение в UserRole.

16 Класс: MainWindow.

Главное окно приложения. Реализует графический интерфейс пользователя с использованием Qt. Управляет всеми данными системы через контейнеры и обеспечивает взаимодействие пользователя с системой. Использует паттерн Command для инкапсуляции операций через классы Action и вспомогательные классы для управления таблицами и фильтрами.

Поля:

‒ ui (std::unique_ptr<Ui::MainWindow>): умный указатель на объект пользовательского интерфейса.

‒ countries_ (DataContainer<Country>): контейнер для хранения стран.

‒ hotels_ (DataContainer<Hotel>): контейнер для хранения отелей.

‒ transportCompanies_ (DataContainer<TransportCompany>): контейнер для хранения транспортных компаний.

‒ tours_ (DataContainer<Tour>): контейнер для хранения туров.

‒ orders_ (DataContainer<Order>): контейнер для хранения заказов.

‒ fileManager_ (FileManager): менеджер для работы с файлами.

‒ networkManager_ (QNetworkAccessManager*): менеджер для работы с сетевыми запросами (обновление курсов валют).

‒ currencyTimer_ (QTimer*): таймер для периодического обновления курсов валют.

‒ tableManager_ (TableManager*): указатель на менеджер таблиц для обновления и управления таблицами.

‒ filterManager_ (FilterManager*): указатель на менеджер фильтров для применения фильтрации к таблицам.

‒ filterComboUpdater_ (FilterComboUpdater*): указатель на обновлятель комбобоксов фильтров.

‒ actions_ (QMap<QString, Action*>): карта действий (Command pattern) для выполнения операций с данными.

Методы:

‒ MainWindow(QWidget* parent): конструктор главного окна. Инициализирует все компоненты интерфейса, создает вспомогательные классы и инициализирует действия.

‒ ~MainWindow(): деструктор главного окна. Освобождает ресурсы и удаляет вспомогательные объекты.

‒ void setupUI(): настройка пользовательского интерфейса.

‒ void setupMenuBar(): настройка меню приложения.

‒ void setupStatusBar(): настройка строки состояния.

‒ void setupTables(): настройка таблиц для отображения данных.

‒ void setupControlsAdaptivity(): настройка адаптивности элементов управления.

‒ void updateTablesFontSize(): обновление размера шрифта в таблицах.

‒ void initializeActions(): инициализация всех действий (Command pattern) и добавление их в карту действий.

‒ void updateCountriesTable(): обновление таблицы стран через TableManager.

‒ void updateHotelsTable(): обновление таблицы отелей через TableManager.

‒ void updateTransportCompaniesTable(): обновление таблицы транспортных компаний через TableManager.

‒ void updateToursTable(): обновление таблицы туров через TableManager.

‒ void updateOrdersTable(): обновление таблицы заказов через TableManager.

‒ void saveData(): сохранение всех данных в файлы.

‒ void loadData(): загрузка всех данных из файлов с валидацией и обработкой ошибок.

‒ void onTabChanged(int index): обработчик изменения вкладки.

‒ void onCountriesHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы стран для трехрежимной сортировки.

‒ void onHotelsHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы отелей для трехрежимной сортировки.

‒ void onTransportHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы транспортных компаний для трехрежимной сортировки.

‒ void onToursHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы туров для трехрежимной сортировки.

‒ void onOrdersHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы заказов для трехрежимной сортировки.

‒ void updateCurrencyRates(): обновление курсов валют через сетевой запрос.

‒ void onCurrencyDataReceived(QNetworkReply* reply): обработчик получения данных о курсах валют.

‒ int getSelectedCountryIndex() const: получение реального индекса выбранной страны в контейнере.

‒ int getSelectedHotelIndex() const: получение реального индекса выбранного отеля в контейнере.

‒ int getSelectedTransportIndex() const: получение реального индекса выбранной транспортной компании в контейнере.

‒ int getSelectedTourIndex() const: получение реального индекса выбранного тура в контейнере.

‒ int getSelectedOrderIndex() const: получение реального индекса выбранного заказа в контейнере.

‒ void linkToursWithHotelsAndTransport(): автоматическое связывание туров с отелями и транспортными компаниями.

‒ void linkOrdersToursWithHotelsAndTransport(): автоматическое связывание туров в заказах с отелями и транспортными компаниями.

‒ QString findCountryCapital(const QString& countryName) const: вспомогательная функция для поиска столицы страны.

‒ QSet<QString> collectTargetCities(const QString& tourCountry, const QString& capital) const: сбор целевых городов для поиска транспорта.

‒ Hotel* findHotelForTour(const QString& tourCountry): поиск подходящего отеля для тура.

‒ bool matchesCity(const QString& arrivalCity, const QSet<QString>& targetCities, const QString& capital, const QString& tourCountry) const: проверка совпадения города прибытия с целевыми городами.

‒ bool findTransportForTour(Tour& tour, const QSet<QString>& targetCities, const QString& capital, const QDate& tourStartDate): поиск подходящего транспорта для тура.

‒ QString findDataDirectory() const: поиск директории с данными.

‒ bool validateDataDirectory(const QString& dataPath): валидация директории с данными.

‒ QStringList checkRequiredFiles(const QString& dataPath): проверка наличия необходимых файлов данных.

‒ void clearAllData(): очистка всех данных из контейнеров.

‒ LoadResult loadAllDataFiles(const QString& dataPath): загрузка всех файлов данных с возвратом результата.

‒ void showLoadResults(const LoadResult& result, const QString& dataPath): отображение результатов загрузки данных.

‒ QWidget* createActionButtons(int dataIndex, const QString& type): создание виджета с кнопками действий для строки таблицы.

‒ void updateCountriesFilterCombo(): обновление комбобокса фильтра стран через FilterComboUpdater.

‒ void updateHotelsFilterCombos(): обновление комбобоксов фильтров отелей через FilterComboUpdater.

‒ void updateTransportFilterCombo(): обновление комбобокса фильтра транспортных компаний через FilterComboUpdater.

‒ void updateToursFilterCombo(): обновление комбобокса фильтра туров через FilterComboUpdater.

‒ void updateOrdersFilterCombo(): обновление комбобокса фильтра заказов через FilterComboUpdater.

‒ void setupCurrencyUpdater(): настройка системы автоматического обновления курсов валют.

17 Класс: Action.

Базовый абстрактный класс для реализации паттерна Command. Используется для инкапсуляции операций с данными в виде объектов, что позволяет реализовать единообразный интерфейс для выполнения различных действий (добавление, редактирование, удаление, просмотр информации).

Поля:

‒ отсутствуют (базовый класс).

Методы:

‒ Action(QObject* parent = nullptr): конструктор базового класса действий.

‒ virtual ~Action(): виртуальный деструктор.

‒ virtual void execute() = 0: чистая виртуальная функция выполнения действия. Должна быть реализована в производных классах.

‒ virtual void undo(): виртуальная функция отмены действия с пустой реализацией по умолчанию. Может быть переопределена в производных классах для поддержки отмены операций.

‒ virtual QString description() const = 0: чистая виртуальная функция, возвращающая описание действия.

Сигналы:

‒ void executed(): сигнал, испускаемый после выполнения действия.

18 Класс: AddCountryAction.

Производный класс от Action для выполнения операции добавления страны. Инкапсулирует операцию добавления новой страны и выполняет её при вызове метода execute().

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог добавления страны.
‒ QString description() const override: возвращает описание действия.

19 Класс: EditCountryAction.

Производный класс от Action для выполнения операции редактирования страны. Инкапсулирует операцию редактирования существующей страны и выполняет её при вызове метода execute().

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог редактирования страны.
‒ QString description() const override: возвращает описание действия.

20 Класс: DeleteCountryAction.

Производный класс от Action для выполнения операции удаления страны. Инкапсулирует операцию удаления страны и выполняет её при вызове метода execute().

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, выполняющая удаление выбранной страны.
‒ QString description() const override: возвращает описание действия.

21 Класс: ShowCountryInfoAction.

Производный класс от Action для выполнения операции просмотра информации о стране. Инкапсулирует операцию отображения подробной информации о стране и выполняет её при вызове метода execute().

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог с информацией о стране.
‒ QString description() const override: возвращает описание действия.

22 Класс: RefreshCountriesAction.

Производный класс от Action для выполнения операции обновления таблицы стран. Инкапсулирует операцию обновления отображения данных в таблице и выполняет её при вызове метода execute().

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, обновляющая таблицу стран.
‒ QString description() const override: возвращает описание действия.

23 Класс: AddHotelAction.

Производный класс от Action для выполнения операции добавления отеля. Инкапсулирует операцию добавления нового отеля и выполняет её при вызове метода execute().

Поля:

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог добавления отеля.
‒ QString description() const override: возвращает описание действия.

24 Класс: EditHotelAction.

Производный класс от Action для выполнения операции редактирования отеля. Инкапсулирует операцию редактирования существующего отеля и выполняет её при вызове метода execute().

Поля:

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог редактирования отеля.
‒ QString description() const override: возвращает описание действия.

25 Класс: DeleteHotelAction.

Производный класс от Action для выполнения операции удаления отеля. Инкапсулирует операцию удаления отеля и выполняет её при вызове метода execute().

Поля:

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, выполняющая удаление выбранного отеля.
‒ QString description() const override: возвращает описание действия.

26 Класс: ShowHotelInfoAction.

Производный класс от Action для выполнения операции просмотра информации об отеле. Инкапсулирует операцию отображения подробной информации об отеле и выполняет её при вызове метода execute().

Поля:

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог с информацией об отеле.
‒ QString description() const override: возвращает описание действия.

27 Класс: RefreshHotelsAction.

Производный класс от Action для выполнения операции обновления таблицы отелей. Инкапсулирует операцию обновления отображения данных в таблице и выполняет её при вызове метода execute().

Поля:

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, обновляющая таблицу отелей.
‒ QString description() const override: возвращает описание действия.

28 Класс: AddTransportCompanyAction.

Производный класс от Action для выполнения операции добавления транспортной компании. Инкапсулирует операцию добавления новой транспортной компании и выполняет её при вызове метода execute().

Поля:

‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог добавления транспортной компании.
‒ QString description() const override: возвращает описание действия.

29 Класс: EditTransportCompanyAction.

Производный класс от Action для выполнения операции редактирования транспортной компании. Инкапсулирует операцию редактирования существующей транспортной компании и выполняет её при вызове метода execute().

Поля:

‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог редактирования транспортной компании.
‒ QString description() const override: возвращает описание действия.

30 Класс: DeleteTransportCompanyAction.

Производный класс от Action для выполнения операции удаления транспортной компании. Инкапсулирует операцию удаления транспортной компании и выполняет её при вызове метода execute().

Поля:

‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, выполняющая удаление выбранной транспортной компании.
‒ QString description() const override: возвращает описание действия.

31 Класс: ShowTransportCompanyInfoAction.

Производный класс от Action для выполнения операции просмотра информации о транспортной компании. Инкапсулирует операцию отображения подробной информации о транспортной компании и выполняет её при вызове метода execute().

Поля:

‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог с информацией о транспортной компании.
‒ QString description() const override: возвращает описание действия.

32 Класс: RefreshTransportCompaniesAction.

Производный класс от Action для выполнения операции обновления таблицы транспортных компаний. Инкапсулирует операцию обновления отображения данных в таблице и выполняет её при вызове метода execute().

Поля:

‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, обновляющая таблицу транспортных компаний.
‒ QString description() const override: возвращает описание действия.

33 Класс: AddTourAction.

Производный класс от Action для выполнения операции добавления тура. Инкапсулирует операцию добавления нового тура и выполняет её при вызове метода execute().

Поля:

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог добавления тура.
‒ QString description() const override: возвращает описание действия.

34 Класс: EditTourAction.

Производный класс от Action для выполнения операции редактирования тура. Инкапсулирует операцию редактирования существующего тура и выполняет её при вызове метода execute().

Поля:

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог редактирования тура.
‒ QString description() const override: возвращает описание действия.

35 Класс: DeleteTourAction.

Производный класс от Action для выполнения операции удаления тура. Инкапсулирует операцию удаления тура и выполняет её при вызове метода execute().

Поля:

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, выполняющая удаление выбранного тура.
‒ QString description() const override: возвращает описание действия.

36 Класс: ShowTourInfoAction.

Производный класс от Action для выполнения операции просмотра информации о туре. Инкапсулирует операцию отображения подробной информации о туре и выполняет её при вызове метода execute().

Поля:

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог с информацией о туре.
‒ QString description() const override: возвращает описание действия.

37 Класс: SearchToursAction.

Производный класс от Action для выполнения операции поиска туров. Инкапсулирует операцию открытия диалога поиска туров по заданным критериям и выполняет её при вызове метода execute().

Поля:

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог поиска туров.
‒ QString description() const override: возвращает описание действия.

38 Класс: RefreshToursAction.

Производный класс от Action для выполнения операции обновления таблицы туров. Инкапсулирует операцию обновления отображения данных в таблице и выполняет её при вызове метода execute().

Поля:

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, обновляющая таблицу туров.
‒ QString description() const override: возвращает описание действия.

39 Класс: AddOrderAction.

Производный класс от Action для выполнения операции добавления заказа. Инкапсулирует операцию добавления нового заказа и выполняет её при вызове метода execute().

Поля:

‒ orders_ (DataContainer<Order>*): указатель на контейнер с заказами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог добавления заказа.
‒ QString description() const override: возвращает описание действия.

40 Класс: EditOrderAction.

Производный класс от Action для выполнения операции редактирования заказа. Инкапсулирует операцию редактирования существующего заказа и выполняет её при вызове метода execute().

Поля:

‒ orders_ (DataContainer<Order>*): указатель на контейнер с заказами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог редактирования заказа.
‒ QString description() const override: возвращает описание действия.

41 Класс: ProcessOrderAction.

Производный класс от Action для выполнения операции изменения статуса заказа. Инкапсулирует операцию изменения статуса заказа (в обработке, подтвержден, оплачен, завершен, отменен) и выполняет её при вызове метода execute().

Поля:

‒ orders_ (DataContainer<Order>*): указатель на контейнер с заказами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, изменяющая статус выбранного заказа.
‒ QString description() const override: возвращает описание действия.

42 Класс: DeleteOrderAction.

Производный класс от Action для выполнения операции удаления заказа. Инкапсулирует операцию удаления заказа и выполняет её при вызове метода execute().

Поля:

‒ orders_ (DataContainer<Order>*): указатель на контейнер с заказами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, выполняющая удаление выбранного заказа.
‒ QString description() const override: возвращает описание действия.

43 Класс: ShowOrderInfoAction.

Производный класс от Action для выполнения операции просмотра информации о заказе. Инкапсулирует операцию отображения подробной информации о заказе и выполняет её при вызове метода execute().

Поля:

‒ orders_ (DataContainer<Order>*): указатель на контейнер с заказами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, открывающая диалог с информацией о заказе.
‒ QString description() const override: возвращает описание действия.

44 Класс: RefreshOrdersAction.

Производный класс от Action для выполнения операции обновления таблицы заказов. Инкапсулирует операцию обновления отображения данных в таблице и выполняет её при вызове метода execute().

Поля:

‒ orders_ (DataContainer<Order>*): указатель на контейнер с заказами.
‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.
‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструктор принимает указатели на контейнер данных, таблицу и родительский виджет.
‒ void execute() override: переопределенная функция выполнения действия, обновляющая таблицу заказов.
‒ QString description() const override: возвращает описание действия.

45 Класс: BookTourCostCalculator.

Вспомогательный класс для расчета стоимости тура при бронировании. Инкапсулирует логику расчета стоимости транспорта, проживания в отеле и общей стоимости тура с учетом различных множителей (категория отеля, страна назначения).

Поля:

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ uiElements_ (BookTourUIElements): структура с указателями на элементы интерфейса для получения выбранных значений.

Методы:

‒ BookTourCostCalculator(DataContainer<Hotel>* hotels, DataContainer<TransportCompany>* companies, const BookTourUIElements& uiElements): конструктор, принимающий контейнеры данных и элементы интерфейса.
‒ double calculateTotalCost() const: вычисляет общую стоимость тура.
‒ double calculateTransportCost() const: вычисляет стоимость транспорта.
‒ double calculateHotelCost() const: вычисляет стоимость проживания в отеле.
‒ int calculateNights() const: вычисляет количество ночей на основе выбранных дат.
‒ double getStarMultiplier(int stars) const: возвращает множитель стоимости в зависимости от категории отеля (количество звезд).
‒ double getCountryMultiplier(const QString& country) const: возвращает множитель стоимости в зависимости от страны назначения.

46 Класс: TourSetupHelper.

Вспомогательный класс для настройки тура в диалоге. Обеспечивает автоматическое заполнение полей диалога при редактировании тура и поиск существующих туров.

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.

Методы:

‒ TourSetupHelper(DataContainer<Country>* countries, DataContainer<Hotel>* hotels, DataContainer<TransportCompany>* companies, DataContainer<Tour>* tours): конструктор, принимающий указатели на все контейнеры данных.
‒ bool findExistingTour(const Tour& tour, int& tourIndex) const: находит существующий тур в контейнере и возвращает его индекс.
‒ void setupTransportAndSchedule(const Tour& tour, QComboBox* countryCombo, QComboBox* transportCombo, QComboBox* scheduleCombo) const: настраивает комбобоксы транспорта и расписания на основе данных тура.
‒ void setupHotelAndRoom(const Tour& tour, QComboBox* countryCombo, QComboBox* hotelCombo, QComboBox* roomCombo) const: настраивает комбобоксы отеля и номера на основе данных тура.
‒ Hotel getSelectedHotel(const QString& country, QComboBox* countryCombo, QComboBox* hotelCombo, QComboBox* roomCombo) const: получает выбранный отель из комбобоксов.
‒ void setupTourTransport(Tour& tour, QComboBox* countryCombo, QComboBox* transportCombo, QComboBox* scheduleCombo) const: настраивает транспорт для тура на основе выбранных значений в комбобоксах.
‒ QString findCountryCapital(const QString& selectedCountry) const: находит столицу выбранной страны.
‒ QSet<QString> collectCitiesInCountry(const QString& selectedCountry) const: собирает все города в выбранной стране (столица, города из адресов отелей).

47 Класс: FilterManager.

Вспомогательный класс для управления фильтрацией данных в таблицах. Инкапсулирует логику применения фильтров к различным типам таблиц, что упрощает код класса MainWindow.

Поля:

‒ отсутствуют (все методы статические или используют только параметры).

Методы:

‒ FilterManager(): конструктор по умолчанию.
‒ void applyCountriesFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* continentCombo, QComboBox* currencyCombo): применяет фильтры к таблице стран.
‒ void applyHotelsFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* countryCombo, QComboBox* starsCombo): применяет фильтры к таблице отелей.
‒ void applyTransportFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* typeCombo): применяет фильтры к таблице транспортных компаний.
‒ void applyToursFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* countryCombo, QLineEdit* minPriceEdit, QLineEdit* maxPriceEdit): применяет фильтры к таблице туров.
‒ void applyOrdersFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* statusCombo, QLineEdit* minCostEdit, QLineEdit* maxCostEdit): применяет фильтры к таблице заказов.
‒ bool matchesSearchText(QTableWidget* table, int row, const QString& searchText) const: проверяет, соответствует ли строка таблицы тексту поиска.
‒ double extractCostFromItem(QTableWidgetItem* item) const: извлекает числовое значение стоимости из элемента таблицы.

48 Класс: TableManager.

Вспомогательный класс для управления таблицами. Инкапсулирует логику обновления таблиц и получения выбранных элементов, что упрощает код класса MainWindow.

Поля:

‒ отсутствуют (все методы используют только параметры).

Методы:

‒ TableManager(): конструктор по умолчанию.
‒ void updateCountriesTable(QTableWidget* table, const DataContainer<Country>& countries): обновляет таблицу стран.
‒ void updateHotelsTable(QTableWidget* table, const DataContainer<Hotel>& hotels): обновляет таблицу отелей.
‒ void updateTransportCompaniesTable(QTableWidget* table, const DataContainer<TransportCompany>& companies): обновляет таблицу транспортных компаний.
‒ void updateToursTable(QTableWidget* table, const DataContainer<Tour>& tours): обновляет таблицу туров.
‒ void updateOrdersTable(QTableWidget* table, const DataContainer<Order>& orders): обновляет таблицу заказов.
‒ int getSelectedRow(QTableWidget* table) const: возвращает индекс выбранной строки в таблице.
‒ int getSelectedIndex(QTableWidget* table, int column) const: возвращает реальный индекс элемента в контейнере на основе выбранной строки таблицы.

49 Класс: FilterComboUpdater.

Вспомогательный класс для обновления комбобоксов фильтров. Автоматически заполняет комбобоксы уникальными значениями из данных для удобной фильтрации.

Поля:

‒ отсутствуют (все методы используют только параметры).

Методы:

‒ FilterComboUpdater(): конструктор по умолчанию.
‒ void updateCountriesFilterCombo(QComboBox* combo, const DataContainer<Country>& countries): обновляет комбобокс фильтра стран.
‒ void updateHotelsFilterCombos(QComboBox* countryCombo, QComboBox* starsCombo, const DataContainer<Hotel>& hotels, const DataContainer<Country>& countries): обновляет комбобоксы фильтров отелей.
‒ void updateTransportFilterCombo(QComboBox* combo, const DataContainer<TransportCompany>& companies): обновляет комбобокс фильтра транспортных компаний.
‒ void updateToursFilterCombo(QComboBox* combo, const DataContainer<Tour>& tours, const DataContainer<Country>& countries): обновляет комбобокс фильтра туров.
‒ void updateOrdersFilterCombo(QComboBox* combo, const DataContainer<Order>& orders): обновляет комбобокс фильтра заказов.

50 Класс: SearchDialog.

Диалоговое окно для поиска туров по заданным критериям. Позволяет фильтровать туры по стране, максимальной стоимости и минимальной продолжительности с использованием STL-алгоритмов.

Поля:

‒ ui (Ui::SearchDialog*): указатель на объект пользовательского интерфейса.
‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами для поиска.

Методы:

‒ SearchDialog(QWidget* parent, DataContainer<Tour>* tours): конструктор диалога поиска.
‒ ~SearchDialog(): деструктор.
‒ void search(): выполнение поиска туров по критериям с использованием std::copy_if.
‒ void onResultSelected(): обработчик выбора результата из таблицы.
‒ void updateResultsTable(const QVector<Tour>& results): обновление таблицы результатов поиска.

51 Класс: CountryDialog.

Диалоговое окно для добавления и редактирования информации о стране.

Поля:

‒ ui (Ui::CountryDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ CountryDialog(QWidget* parent): конструктор диалога.
‒ ~CountryDialog(): деструктор.
‒ void setCountry(const Country& country): установка данных страны для редактирования.
‒ Country getCountry() const: получение данных введенной или измененной страны.

52 Класс: HotelDialog.

Диалоговое окно для добавления и редактирования информации об отеле.

Поля:

‒ ui (Ui::HotelDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ HotelDialog(QWidget* parent, const DataContainer<Country>* countries): конструктор диалога с доступом к списку стран.
‒ ~HotelDialog(): деструктор.
‒ void setHotel(const Hotel& hotel): установка данных отеля для редактирования.
‒ Hotel getHotel() const: получение данных введенного или измененного отеля.

53 Класс: CompanyDialog.

Диалоговое окно для добавления и редактирования информации о транспортной компании.

Поля:

‒ ui (std::unique_ptr<Ui::CompanyDialog>): умный указатель на объект пользовательского интерфейса.
‒ company_ (TransportCompany*): указатель на редактируемую транспортную компанию (nullptr при создании новой).
‒ schedules_ (QVector<TransportSchedule>): вектор расписаний рейсов.

Методы:

‒ CompanyDialog(QWidget* parent, TransportCompany* company): конструктор диалога с указателем на редактируемую компанию.
‒ ~CompanyDialog(): деструктор.
‒ TransportCompany getCompany() const: получение данных введенной или измененной компании.
‒ void accept() override: обработчик подтверждения диалога с валидацией данных.
‒ void addSchedule(): добавление нового расписания рейса.
‒ void editSchedule(): редактирование выбранного расписания рейса.
‒ void deleteSchedule(): удаление выбранного расписания рейса.
‒ void updateSchedulesTable(): обновление таблицы расписаний.

54 Класс: RoomDialog.

Диалоговое окно для добавления и редактирования информации о номере отеля.

Поля:

‒ ui (std::unique_ptr<Ui::RoomDialog>): умный указатель на объект пользовательского интерфейса.
‒ room_ (Room*): указатель на редактируемый номер (nullptr при создании нового).

Методы:

‒ RoomDialog(QWidget* parent, Room* room): конструктор диалога с указателем на редактируемый номер.
‒ ~RoomDialog(): деструктор.
‒ Room getRoom() const: получение данных введенного или измененного номера.
‒ void accept() override: обработчик подтверждения диалога с валидацией данных.

55 Класс: ScheduleDialog.

Диалоговое окно для добавления и редактирования расписания рейса транспортной компании.

Поля:

‒ ui (std::unique_ptr<Ui::ScheduleDialog>): умный указатель на объект пользовательского интерфейса.
‒ schedule_ (TransportSchedule*): указатель на редактируемое расписание (nullptr при создании нового).

Методы:

‒ ScheduleDialog(QWidget* parent, TransportSchedule* schedule): конструктор диалога с указателем на редактируемое расписание.
‒ ~ScheduleDialog(): деструктор.
‒ TransportSchedule getSchedule() const: получение данных введенного или измененного расписания.
‒ void accept() override: обработчик подтверждения диалога с валидацией данных.

56 Класс: TourDialog.

Диалоговое окно для добавления и редактирования информации о туре.

Поля:

‒ ui (std::unique_ptr<Ui::TourDialog>): умный указатель на объект пользовательского интерфейса.
‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ tour_ (Tour*): указатель на редактируемый тур (nullptr при создании нового).
‒ tourSetupHelper_ (std::unique_ptr<TourSetupHelper>): умный указатель на вспомогательный класс для настройки тура.

Методы:

‒ TourDialog(QWidget* parent, DataContainer<Country>* countries, DataContainer<Hotel>* hotels, DataContainer<TransportCompany>* companies, Tour* tour): конструктор диалога с доступом к контейнерам данных и указателем на редактируемый тур.
‒ ~TourDialog(): деструктор.
‒ Tour getTour() const: получение данных введенного или измененного тура.
‒ void accept() override: обработчик подтверждения диалога с валидацией данных.
‒ void onCountryChanged(): обработчик изменения выбранной страны.
‒ void onHotelChanged(): обработчик изменения выбранного отеля.
‒ void onTransportChanged(): обработчик изменения выбранной транспортной компании.
‒ void calculateCost(): расчет и отображение стоимости тура.
‒ void updateHotelsCombo(): обновление списка отелей в комбобоксе.
‒ void updateRoomsCombo(): обновление списка номеров в комбобоксе.
‒ void updateTransportCombo(): обновление списка транспортных компаний в комбобоксе.
‒ void updateSchedulesCombo(): обновление списка расписаний в комбобоксе.
‒ double calculateTransportCost() const: расчет стоимости транспорта.
‒ double calculateHotelCost() const: расчет стоимости проживания в отеле.
‒ TransportCompany* findSelectedTransportCompany() const: находит выбранную транспортную компанию.
‒ Hotel getSelectedHotel(const QString& country) const: получает выбранный отель.
‒ void setupTourTransport(Tour& tour, const QString& country) const: настраивает транспорт для тура.
‒ bool hasRelevantScheduleForCountry(const TransportCompany& company, const QSet<QString>& citiesInCountry, const QString& capital) const: проверяет наличие релевантного расписания для страны.
‒ void populateScheduleCombo(TransportCompany* company, const QSet<QString>& citiesInCountry, const QString& capital) const: заполняет комбобокс расписаний.

57 Класс: BookTourDialog.

Диалоговое окно для бронирования тура (создания заказа). Поддерживает два режима: выбор существующего тура или создание нового тура при бронировании.

Поля:

‒ ui (std::unique_ptr<Ui::BookTourDialog>): умный указатель на объект пользовательского интерфейса.
‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.
‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.
‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.
‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.
‒ isEditMode_ (bool): флаг режима редактирования заказа.
‒ costCalculator_ (std::unique_ptr<BookTourCostCalculator>): умный указатель на калькулятор стоимости тура.
‒ tourSetupHelper_ (std::unique_ptr<TourSetupHelper>): умный указатель на вспомогательный класс для настройки тура.

Методы:

‒ BookTourDialog(QWidget* parent, DataContainer<Country>* countries, DataContainer<Hotel>* hotels, DataContainer<TransportCompany>* companies, DataContainer<Tour>* tours): конструктор диалога с доступом ко всем контейнерам данных.
‒ ~BookTourDialog(): деструктор.
‒ Order getOrder() const: получение данных введенного или измененного заказа.
‒ void setOrder(const Order& order): установка данных заказа для редактирования.
‒ void setEditMode(bool editMode): установка режима редактирования.
‒ void accept() override: обработчик подтверждения диалога с валидацией данных.
‒ void onModeChanged(): обработчик изменения режима (выбор тура / создание тура).
‒ void onCountryChanged(): обработчик изменения выбранной страны.
‒ void onTransportChanged(): обработчик изменения выбранной транспортной компании.
‒ void onHotelChanged(): обработчик изменения выбранного отеля.
‒ void onDatesChanged(): обработчик изменения дат поездки.
‒ void calculateCost(): расчет и отображение стоимости тура.
‒ void calculateCostForSelectMode(): расчет стоимости для режима выбора существующего тура.
‒ void calculateCostForCreateMode(): расчет стоимости для режима создания нового тура.
‒ void updateTransportCombo(): обновление списка транспортных компаний в комбобоксе.
‒ void updateHotelsCombo(): обновление списка отелей в комбобоксе.
‒ void updateRoomsCombo(): обновление списка номеров в комбобоксе.
‒ void updateToursCombo(): обновление списка туров в комбобоксе.
‒ void updateUIForMode(): обновление интерфейса в зависимости от выбранного режима.
‒ bool findExistingTour(const Tour& tour, int& tourIndex): поиск существующего тура в контейнере.
‒ void setupSelectMode(int tourIndex, const QString& clientName, const QString& clientPhone, const QString& clientEmail): настройка диалога для режима выбора существующего тура.
‒ void setupCreateMode(const Tour& tour, const QString& clientName, const QString& clientPhone, const QString& clientEmail): настройка диалога для режима создания нового тура.
‒ void setupTransportAndSchedule(const Tour& tour): настройка транспорта и расписания на основе данных тура.
‒ void setupHotelAndRoom(const Tour& tour): настройка отеля и номера на основе данных тура.
‒ Tour getTourFromSelectMode() const: получение тура из режима выбора существующего тура.
‒ Tour getTourFromCreateMode() const: получение тура из режима создания нового тура.
‒ Hotel getSelectedHotel(const QString& country) const: получение выбранного отеля.
‒ void setupTourTransport(Tour& tour) const: настройка транспорта для тура.
‒ QString findCountryCapital(const QString& selectedCountry) const: находит столицу выбранной страны.
‒ QSet<QString> collectCitiesInCountry(const QString& selectedCountry) const: собирает все города в выбранной стране.
‒ TransportCompany* findSelectedTransportCompany() const: находит выбранную транспортную компанию.
‒ void populateScheduleCombo(TransportCompany* company, const QSet<QString>& citiesInCountry, const QString& capital) const: заполняет комбобокс расписаний.
‒ bool validateClientData(const QString& name, const QString& phone, const QString& email) const: валидация данных клиента.
‒ bool validateSelectMode() const: валидация данных в режиме выбора тура.
‒ bool validateCreateMode() const: валидация данных в режиме создания тура.

3.2 Примеры кода

3.2.1 Функция расчета стоимости отеля с учетом множителей (BookTourCostCalculator::calculateHotelCost)

Функция отвечает за расчет стоимости проживания в отеле с учетом категории отеля (количество звезд) и количества ночей. Модульность: получение данных из UI — через uiElements_; расчет множителей — через getStarMultiplier(); поиск отеля и номера — через итерацию по контейнеру.

Принципы:

‒ Валидация входных данных: проверка наличия отелей, корректности выбранных индексов и положительности количества ночей.

‒ Итеративный поиск: перебор отелей по стране с учетом выбранного индекса в комбобоксе.

‒ Применение множителей: учет категории отеля при расчете итоговой стоимости.

Основные фрагменты кода:

1 Проверка валидности входных данных и получение выбранной страны.

```cpp
double BookTourCostCalculator::calculateHotelCost() const {
    int nights = calculateNights();
    if (!hotels_ || uiElements_.hotelCombo->currentIndex() < 0 || 
        uiElements_.roomCombo->currentIndex() < 0 || nights <= 0) {
        return 0.0;
    }
    
    QString selectedCountry = uiElements_.countryCombo->currentText();
    int hotelIndex = 0;
```

Этот фрагмент проверяет наличие необходимых данных для расчета: контейнер отелей, выбранные индексы в комбобоксах и положительное количество ночей. При отсутствии данных функция возвращает нулевую стоимость.

2 Поиск отеля по стране и индексу, вычисление множителя категории.

```cpp
    for (const auto& hotel : hotels_->getData()) {
        if (hotel.getCountry() != selectedCountry) {
            continue;
        }
        
        if (hotelIndex != uiElements_.hotelCombo->currentIndex()) {
            hotelIndex++;
            continue;
        }
        
        double starMultiplier = getStarMultiplier(hotel.getStars());
```

Фрагмент выполняет итерацию по всем отелям, фильтруя их по выбранной стране и находя отель с нужным индексом в списке отелей этой страны. После нахождения отеля вычисляется множитель стоимости на основе его категории (количество звезд).

3 Получение номера и расчет итоговой стоимости.

```cpp
        if (uiElements_.roomCombo->currentIndex() >= hotel.getRoomCount()) {
            break;
        }
        
        const Room* room = hotel.getRoom(uiElements_.roomCombo->currentIndex());
        if (!room) {
            break;
        }
        
        double basePrice = room->getPricePerNight();
        return basePrice * starMultiplier * nights;
    }
    
    return 0.0;
}
```

Фрагмент проверяет доступность выбранного номера в отеле, получает базовую цену номера за ночь и рассчитывает итоговую стоимость как произведение базовой цены, множителя категории отеля и количества ночей. При отсутствии номера функция возвращает нулевую стоимость.

3.2.2 Функция проверки совпадения города прибытия (MainWindow::matchesCity)

Функция отвечает за проверку совпадения города прибытия рейса с целевыми городами тура с учетом различных вариантов сравнения. Модульность: нормализация регистра — через toLower(); проверка совпадений — через сравнение строк и contains(); обработка специальных случаев — для определенных стран.

Принципы:

‒ Многоуровневая проверка: сначала целевые города, затем столица, затем специальные случаи.

‒ Гибкое сравнение: точное совпадение, совпадение без учета регистра, частичное совпадение (содержание подстроки).

‒ Обработка исключений: специальные правила для стран с несколькими популярными городами (например, ОАЭ).

Ключевые фрагменты кода и их описание:

1 Нормализация регистра и проверка совпадения с целевыми городами.

```cpp
bool MainWindow::matchesCity(const QString& arrivalCity, const QSet<QString>& targetCities, 
                            const QString& capital, const QString& tourCountry) const {
    QString arrivalCityLower = arrivalCity.toLower();
    
    // Проверяем точное совпадение с целевыми городами
    if (!targetCities.isEmpty()) {
        for (const QString& targetCity : targetCities) {
            QString targetCityLower = targetCity.toLower();
            if (arrivalCity == targetCity || 
                arrivalCityLower == targetCityLower ||
                arrivalCityLower.contains(targetCityLower) ||
                targetCityLower.contains(arrivalCityLower)) {
                return true;
            }
        }
    }
```

Фрагмент нормализует регистр города прибытия и перебирает целевые города тура, проверяя точное совпадение, совпадение без учета регистра и частичное совпадение (когда один город содержит название другого). Это повышает вероятность нахождения подходящего рейса при различных вариантах написания.

2 Проверка совпадения со столицей страны.

```cpp
    // Проверяем совпадение со столицей
    if (!capital.isEmpty()) {
        QString capitalLower = capital.toLower();
        if (arrivalCityLower == capitalLower ||
            arrivalCityLower.contains(capitalLower) || 
            capitalLower.contains(arrivalCityLower)) {
            return true;
        }
    }
```

Фрагмент проверяет совпадение города прибытия со столицей страны тура, используя те же правила сравнения, что и для целевых городов. Столица часто является основным пунктом назначения, поэтому такая проверка важна для корректного подбора транспорта.

3 Обработка специальных случаев для определенных стран.

```cpp
    // Специальные случаи (например, для ОАЭ)
    if (tourCountry == "ОАЭ") {
        if (arrivalCityLower.contains("дубай") || arrivalCityLower.contains("абу-даби") || 
            arrivalCityLower.contains("abu dhabi") || arrivalCityLower.contains("dubai")) {
            return true;
        }
    }
    
    return false;
}
```

Фрагмент обрабатывает специальные случаи для стран с несколькими популярными туристическими городами. Для ОАЭ учитываются как столица (Абу-Даби), так и популярный туристический город (Дубай), причем проверяются варианты написания как на кириллице, так и на латинице. Это повышает вероятность нахождения подходящего рейса для таких стран.

3.2.3 Функция поиска транспорта для тура (MainWindow::findTransportForTour)

Функция отвечает за автоматический поиск подходящей транспортной компании и рейса для тура на основе города прибытия и даты отправления. Модульность: проверка города — через matchesCity(); проверка дат — через сравнение QDate; установка транспорта — через setTransportCompany() и setTransportSchedule().

Принципы:

‒ Итеративный поиск: вложенные циклы для перебора всех компаний и их расписаний.

‒ Комплексная проверка: совпадение города прибытия и соответствие даты отправления.

‒ Раннее завершение: возврат при первом найденном подходящем рейсе.

Ключевые фрагменты кода и их описание:

1 Перебор транспортных компаний и их расписаний, извлечение данных рейса.

```cpp
bool MainWindow::findTransportForTour(Tour& tour, const QSet<QString>& targetCities, 
                                       const QString& capital, const QDate& tourStartDate) {
    for (auto& company : transportCompanies_.getData()) {
        for (int i = 0; i < company.getScheduleCount(); ++i) {
            TransportSchedule* schedule = company.getSchedule(i);
            if (!schedule) {
                continue;
            }
            
            QString arrivalCity = schedule->arrivalCity;
            QDate scheduleDepartureDate = schedule->departureDate;
```

Фрагмент использует вложенные циклы для перебора всех транспортных компаний и их расписаний. Для каждого рейса проверяется наличие расписания, затем извлекаются город прибытия и дата отправления для дальнейшей проверки.

2 Проверка совпадения города прибытия через вспомогательную функцию.

```cpp
            // Проверяем совпадение города
            if (!matchesCity(arrivalCity, targetCities, capital, tour.getCountry())) {
                continue;
            }
```

Фрагмент вызывает функцию matchesCity() для проверки совпадения города прибытия рейса с целевыми городами тура. Если совпадение не найдено, выполнение переходит к следующему рейсу.

3 Проверка соответствия даты отправления и установка транспорта для тура.

```cpp
            // Проверяем совпадение дат
            bool dateMatches = !tourStartDate.isValid() || 
                              !scheduleDepartureDate.isValid() ||
                              scheduleDepartureDate <= tourStartDate;
            
            if (dateMatches || !tourStartDate.isValid()) {
                tour.setTransportCompany(company);
                tour.setTransportSchedule(*schedule);
                return true;
            }
        }
    }
    return false;
}
```

Фрагмент проверяет соответствие даты отправления рейса дате начала тура (рейс должен быть не позже даты начала тура или даты могут быть невалидными). Если проверка пройдена, транспортная компания и расписание устанавливаются для тура, и функция возвращает true. Это обеспечивает автоматическое связывание туров с подходящим транспортом при создании или редактировании тура.

3.3 Разработка алгоритмов

Схема алгоритма расчета стоимости отеля представлена в приложении Б, схема алгоритма проверки совпадения города представлена в приложении В, схема алгоритма поиска транспорта для тура представлена в приложении Г.

3.3.1 Алгоритм расчета стоимости отеля с учетом множителей

Алгоритм вычисляет стоимость проживания в отеле с учетом категории отеля (количество звезд) и количества ночей. Содержит множественные проверки условий, цикл для поиска отеля и вычисления с множителями, что делает его подходящим для представления в виде блок-схемы.

Реализация алгоритма находится в методе `calculateHotelCost()` класса `BookTourCostCalculator` в файле `src/dialogs/booktourcostcalculator.cpp` (строки 36-72).

Шаг 1: Начало.

Шаг 2: Определение количества ночей проживания.

Шаг 3: Проверка наличия необходимых данных для расчета (наличие отелей, выбранных параметров, положительного количества ночей).

Шаг 4: Если данные некорректны, возврат нулевой стоимости и завершение алгоритма.

Шаг 5: Получение выбранной страны тура.

Шаг 6: Поиск отеля, соответствующего выбранной стране и выбранному индексу.

Шаг 7: Если отель не найден, возврат нулевой стоимости и завершение алгоритма.

Шаг 8: Определение множителя стоимости на основе категории отеля (количество звезд).

Шаг 9: Получение информации о выбранном номере в найденном отеле.

Шаг 10: Если номер недоступен, возврат нулевой стоимости и завершение алгоритма.

Шаг 11: Получение базовой стоимости номера за одну ночь.

Шаг 12: Вычисление итоговой стоимости как произведение базовой стоимости, множителя категории и количества ночей.

Шаг 13: Возврат вычисленной стоимости и завершение алгоритма.

3.3.2 Алгоритм проверки совпадения города прибытия

Алгоритм проверяет совпадение города прибытия рейса с целевыми городами с учетом различных вариантов сравнения. Содержит множественные проверки условий, цикл для перебора целевых городов и обработку специальных случаев, что делает его подходящим для блок-схемы.

Реализация алгоритма находится в методе `matchesCity()` класса `MainWindow` в файле `src/mainwindow.cpp` (строки 2505-2541).

Шаг 1: Начало.

Шаг 2: Нормализация названия города прибытия для сравнения (приведение к единому регистру).

Шаг 3: Проверка совпадения города прибытия с целевыми городами тура (точное или частичное совпадение без учета регистра).

Шаг 4: Если совпадение найдено, возврат положительного результата и завершение алгоритма.

Шаг 5: Проверка совпадения города прибытия со столицей страны тура (точное или частичное совпадение без учета регистра).

Шаг 6: Если совпадение со столицей найдено, возврат положительного результата и завершение алгоритма.

Шаг 7: Проверка специальных случаев для определенных стран (например, ОАЭ с альтернативными названиями городов).

Шаг 8: Если специальный случай обработан и совпадение найдено, возврат положительного результата и завершение алгоритма.

Шаг 9: Возврат отрицательного результата (совпадение не найдено) и завершение алгоритма.

3.3.3 Алгоритм поиска транспорта для тура

Алгоритм выполняет автоматический поиск подходящей транспортной компании и рейса для тура. Содержит вложенные циклы, множественные проверки условий и вызовы вспомогательных функций, что делает его подходящим для блок-схемы.

Реализация алгоритма находится в методе `findTransportForTour()` класса `MainWindow` в файле `src/mainwindow.cpp` (строки 2543-2573).

Шаг 1: Начало.

Шаг 2: Перебор всех доступных транспортных компаний.

Шаг 3: Для каждой транспортной компании перебор всех расписаний рейсов.

Шаг 4: Извлечение информации о городе прибытия и дате отправления из текущего расписания.

Шаг 5: Проверка соответствия города прибытия рейса целевым городам тура.

Шаг 6: Если город не соответствует, переход к следующему расписанию.

Шаг 7: Проверка соответствия даты отправления рейса дате начала тура (рейс должен быть не позднее начала тура).

Шаг 8: Если даты не соответствуют, переход к следующему расписанию.

Шаг 9: Назначение найденной транспортной компании и расписания туру.

Шаг 10: Возврат положительного результата (транспорт найден) и завершение алгоритма.

Шаг 11: Если все компании и расписания проверены без результата, возврат отрицательного результата (транспорт не найден) и завершение алгоритма.

3.4 Особенности работы с используемыми библиотеками

В данном проекте используются библиотеки Qt и стандартная библиотека C++ (STL), предоставляющие мощные инструменты для разработки графических пользовательских интерфейсов и работы с данными. Qt обеспечивает кроссплатформенное создание интуитивно понятных интерфейсов, а STL предоставляет эффективные алгоритмы и контейнеры для работы с данными.

Особенности использования библиотек и инструментов:

1. Графические пользовательские интерфейсы

Управление виджетами:

Используются классы QMainWindow, QWidget и производные для создания окон и диалогов. Класс MainWindow инкапсулирует функционал работы с турами, отелями, странами, транспортными компаниями и заказами. В окнах реализована связь кнопок с методами через механизмы сигналов и слотов Qt. Это позволяет динамически обрабатывать пользовательские действия и вызывать соответствующие функции.

Использование QTableWidget:

Для отображения данных используются таблицы QTableWidget, которые обеспечивают удобное представление информации в виде строк и столбцов. Таблицы поддерживают сортировку по столбцам, выбор строк и настройку внешнего вида. Для корректной числовой сортировки используется кастомный класс NumericSortItem, который хранит числовое значение отдельно от текстового представления.

2. Диалоговые окна и взаимодействие с пользователем

Модальные диалоги:

Используются диалоговые окна (CountryDialog, HotelDialog, TourDialog, SearchDialog, BookTourDialog) для ввода данных и отображения информации пользователю. Диалоги открываются в модальном режиме через метод exec(), что обеспечивает блокировку основного окна до завершения работы с диалогом. Это концентрирует внимание пользователя на текущей задаче и предотвращает конфликты действий.

Отображение сообщений:

Предупреждения о неверных данных отображаются через QMessageBox::warning, ошибки через QMessageBox::critical, информационные сообщения через QMessageBox::information. Это обеспечивает единообразный интерфейс уведомлений пользователя.

3. Работа с данными и контейнерами

Шаблонный контейнер DataContainer:

Реализован шаблонный контейнер DataContainer для типобезопасного хранения данных различных типов. Контейнер использует QVector для внутреннего хранения и предоставляет итераторы для использования STL-алгоритмов. Это обеспечивает гибкость и эффективность работы с данными.

Использование STL-алгоритмов:

Применяются STL-алгоритмы (std::copy_if, std::sort, std::find_if) для фильтрации и сортировки данных. Это обеспечивает эффективную обработку больших объемов данных и улучшает читаемость кода. Лямбда-функции используются в качестве предикатов для алгоритмов, что делает код компактным и выразительным.

4. Работа с файлами

QFile и QTextStream:

Для работы с файлами используются классы QFile и QTextStream из Qt. QFile обеспечивает доступ к файлам файловой системы, а QTextStream предоставляет удобный интерфейс для чтения и записи текстовых данных. Использование кодировки UTF-8 через QStringConverter::Encoding::Utf8 обеспечивает корректную работу с кириллицей.

Обработка ошибок:

Для обработки ошибок работы с файлами используются классы FileException и StreamFileException, наследующиеся от std::exception. Это обеспечивает единообразную обработку ошибок через механизм исключений. FileException используется для работы с файлами через QFile и QTextStream, а StreamFileException — для работы через стандартные потоки C++ (std::ifstream, std::ofstream).

Работа с потоками C++:

Для демонстрации различных подходов к работе с файлами в проекте реализован класс StreamFileManager, который использует стандартные потоки C++ (std::ifstream, std::ofstream) для сохранения и загрузки данных о странах и заказах. Это демонстрирует перегрузку операторов ввода/вывода (operator<< и operator>>) для классов Country и Order, что обеспечивает удобную работу с потоками.

5. Механизм сигналов и слотов

Интерактивность интерфейса:

В приложении активно используется механизм сигналов и слотов Qt. Например, в MainWindow кнопки связываются с функциями через connect(), что позволяет обрабатывать пользовательские действия. Сигналы и слоты обеспечивают слабую связанность компонентов, что упрощает разработку и поддержку кода.

Обработка событий:

Сигналы от виджетов (например, clicked() от кнопок, currentChanged() от вкладок, sectionClicked() от заголовков таблиц) связываются со слотами для обработки соответствующих событий. Это обеспечивает событийно-ориентированную архитектуру приложения.

6. Работа с датами и временем

QDate и QDateTime:

Для работы с датами используются классы QDate и QDateTime из Qt. QDate предоставляет функциональность для работы с датами (сравнение, вычисление разницы в днях), а QDateTime объединяет дату и время. Метод daysTo() используется для вычисления продолжительности тура в днях.

7. Работа со строками

QString:

Для работы со строками используется класс QString из Qt, который обеспечивает удобную работу с Unicode-строками. Методы contains(), toLower(), split(), trimmed() используются для обработки текстовых данных, таких как названия стран, городов и адресов. Для преобразования между QString и std::string используются методы toStdString() и fromStdString().

8. Работа с сетью

QNetworkAccessManager и QNetworkReply:

Для работы с сетевыми запросами используются классы QNetworkAccessManager и QNetworkReply из модуля Qt Network. В проекте реализована функциональность автоматического обновления курсов валют через сетевые запросы. QNetworkAccessManager отправляет асинхронные HTTP-запросы, а обработка ответов выполняется в слоте, подключенном к сигналу finished() через механизм сигналов и слотов.

QTimer:

Для периодического обновления курсов валют используется класс QTimer. Таймер настраивается на автоматический запуск сетевых запросов через заданные интервалы времени, что обеспечивает актуальность информации о курсах валют без вмешательства пользователя.

9. Работа с коллекциями Qt

QVector и QSet:

В проекте используются контейнеры Qt: QVector для хранения упорядоченных коллекций (например, номеров отелей, расписаний рейсов) и QSet для хранения уникальных элементов (например, целевых городов при поиске транспорта). QSet обеспечивает быструю проверку наличия элемента и автоматическое исключение дубликатов.

QDate методы:

Класс QDate используется не только для хранения дат, но и для их сравнения и валидации через метод isValid(). Метод daysTo() вычисляет разницу в днях между двумя датами, что критично для расчета продолжительности туров и стоимости проживания.

10. Стабильность работы приложения

Обработка исключений:

Для обеспечения стабильности работы приложения используются исключения для обработки ошибок. Исключения перехватываются в соответствующих блоках try-catch, и пользователю отображаются понятные сообщения об ошибках через QMessageBox.

Валидация данных:

Перед выполнением операций выполняется валидация входных данных (проверка на пустые поля, корректность дат, наличие данных в контейнерах). Это предотвращает ошибки и обеспечивает целостность данных. Используются методы isEmpty() для проверки пустоты строк и контейнеров, isValid() для проверки корректности дат.

11. Производительность

Использование итераторов:

Использование итераторов для обхода контейнеров обеспечивает эффективный доступ к элементам. Итераторы поддерживают операции инкремента, декремента и арифметические операции, что позволяет использовать STL-алгоритмы для обработки данных.

Кэширование вычислений:

Стоимость туров вычисляется динамически при каждом обращении, что гарантирует актуальность данных. Однако при отображении в таблице стоимость вычисляется один раз и сохраняется в NumericSortItem для отображения и сортировки.

Эффективная фильтрация:

Для фильтрации данных в таблицах используется механизм скрытия строк через setRowHidden() вместо пересоздания таблицы, что обеспечивает быструю работу фильтров даже с большими объемами данных.

12. Кроссплатформенность

Qt Framework:

Использование Qt Framework обеспечивает кроссплатформенность приложения. Код, написанный с использованием Qt, может быть скомпилирован для различных платформ (Windows, Linux, macOS) без изменений, что упрощает развертывание и поддержку приложения.

13. Особенности многопоточности

Асинхронные сетевые запросы:

QNetworkAccessManager выполняет сетевые запросы асинхронно, не блокируя основной поток выполнения. Это обеспечивает отзывчивость интерфейса даже при выполнении длительных сетевых операций. Результаты запросов обрабатываются в главном потоке через механизм сигналов и слотов.

14. Полиморфизм и наследование

Виртуальные функции:

В проекте активно используется полиморфизм через виртуальные функции. Базовый класс TouristService определяет виртуальные функции getType(), getDescription() и calculateCost(), которые переопределяются в производных классах (Country, Hotel, Room, TransportCompany, Tour). Это позволяет единообразно работать с различными типами туристических услуг через указатели или ссылки на базовый класс.

Перегрузка операторов:

В проекте реализована перегрузка операторов для классов Country и Order. Операторы сравнения (==, !=, <) обеспечивают удобное сравнение объектов. Операторы ввода/вывода в потоки (operator<<, operator>>) обеспечивают удобную сериализацию и десериализацию данных при работе с файлами через стандартные потоки C++.

15. Трехрежимная сортировка таблиц

QHeaderView и сортировка:

В проекте реализована трехрежимная сортировка таблиц: по возрастанию, по убыванию и отмена сортировки (возврат к исходному порядку). Это достигается через обработку сигнала sectionClicked() от заголовков таблиц и управление порядком сортировки через setSortingEnabled(). Для каждого столбца отслеживается текущий режим сортировки, что обеспечивает интуитивно понятное поведение при повторных кликах по заголовку.

16. Паттерн Command для инкапсуляции операций

Action и производные классы:

В проекте реализован паттерн Command через базовый класс Action и производные классы для различных операций (добавление, редактирование, удаление, просмотр информации). Это позволяет инкапсулировать операции в виде объектов, что упрощает управление действиями пользователя и обеспечивает возможность расширения функциональности без изменения основного кода. Все действия хранятся в карте QMap<QString, Action*> и выполняются через единый интерфейс метода execute().


ЗАКЛЮЧЕНИЕ

В ходе выполнения курсовой работы была разработана система управления туристическим агентством, представляющая собой полнофункциональное настольное приложение для автоматизации процессов работы туристического агентства.

Основные результаты работы:

1. Разработана объектно-ориентированная архитектура приложения с использованием паттернов проектирования и принципов ООП. Реализована иерархия классов с базовым абстрактным классом TouristService и производными классами Country, Hotel, Room, TransportCompany и Tour, демонстрирующая принципы наследования и полиморфизма.

2. Реализован шаблонный контейнер DataContainer с поддержкой итераторов, совместимых со стандартной библиотекой C++ (STL). Это обеспечило возможность использования STL-алгоритмов (std::copy_if, std::sort, std::find_if) для эффективной обработки данных.

3. Создан графический интерфейс пользователя с использованием фреймворка Qt, включающий главное окно с вкладками для управления различными типами данных и набор диалоговых окон для ввода и редактирования информации. Реализована трехрежимная сортировка таблиц и система фильтрации данных.

4. Разработана система хранения данных на основе текстовых файлов с поддержкой кодировки UTF-8 для корректной работы с кириллицей. Реализованы два подхода к работе с файлами: через классы Qt (QFile, QTextStream) и через стандартные потоки C++ (std::ifstream, std::ofstream).

5. Реализована функция автоматического формирования туров с расчетом стоимости на основе выбранных услуг. Система автоматически связывает туры с отелями и транспортными компаниями на основе страны назначения и дат поездки.

6. Создана система управления заказами с поддержкой различных статусов обработки и автоматическим расчетом стоимости на основе выбранного тура.

7. Реализован функционал поиска туров по критериям с использованием STL-алгоритмов и лямбда-функций, обеспечивающий гибкую фильтрацию по стране, стоимости и продолжительности.

8. Добавлена функциональность работы с сетью для получения курсов валют через QNetworkAccessManager с асинхронной обработкой запросов.

9. Все туристические маршруты в системе отправляются из города Минск (Беларусь), что соответствует специфике работы туристического агентства.

Разработанная система демонстрирует практическое применение концепций объектно-ориентированного программирования, включая наследование, полиморфизм, инкапсуляцию, шаблоны, перегрузку операторов и обработку исключений. В проекте также реализован паттерн проектирования Command для инкапсуляции операций с данными, что обеспечивает гибкость и расширяемость системы. Использование фреймворка Qt обеспечивает кроссплатформенность приложения и возможность его развертывания на различных операционных системах.

Система может быть использована небольшими туристическими агентствами для автоматизации процессов управления турами и заказами, обеспечивая эффективную работу с данными и снижение вероятности ошибок при ручной обработке информации.

Направления дальнейшего развития:

‒ Интеграция с внешними системами бронирования отелей и транспорта.

‒ Реализация системы отчетности и аналитики для анализа продаж и популярных направлений.

‒ Добавление функциональности работы с платежными системами для онлайн-оплаты туров.

‒ Расширение функционала поиска и фильтрации с использованием более сложных критериев.

‒ Реализация многопользовательского режима работы с разграничением прав доступа.

‒ Добавление возможности экспорта данных в различные форматы (PDF, Excel, CSV).


СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ

1. Stroustrup, B. The C++ Programming Language (4th Edition) / B. Stroustrup. — Addison-Wesley Professional, 2013. — 1376 p.

2. Meyers, S. Effective C++: 55 Specific Ways to Improve Your Programs and Designs (3rd Edition) / S. Meyers. — Addison-Wesley Professional, 2005. — 320 p.

3. Gamma, E. Design Patterns: Elements of Reusable Object-Oriented Software / E. Gamma, R. Helm, R. Johnson, J. Vlissides. — Addison-Wesley Professional, 1994. — 395 p.

4. Blanchette, J. C++ GUI Programming with Qt 4 (2nd Edition) / J. Blanchette, M. Summerfield. — Prentice Hall, 2008. — 752 p.

5. Qt Documentation: Qt 6.10 Reference Documentation [Electronic resource]. — Mode of access: https://doc.qt.io/qt-6/. — Date of access: 16.11.2025.

6. cppreference.com: C++ reference [Electronic resource]. — Mode of access: https://en.cppreference.com/. — Date of access: 16.11.2025.

7. Josuttis, N. M. The C++ Standard Library: A Tutorial and Reference (2nd Edition) / N. M. Josuttis. — Addison-Wesley Professional, 2012. — 1128 p.

8. Sutter, H. Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions / H. Sutter. — Addison-Wesley Professional, 1999. — 240 p.

9. Alexandrescu, A. Modern C++ Design: Generic Programming and Design Patterns Applied / A. Alexandrescu. — Addison-Wesley Professional, 2001. — 352 p.

10. Qt Network Module Documentation [Electronic resource]. — Mode of access: https://doc.qt.io/qt-6/qtnetwork-index.html. — Date of access: 16.11.2025.


ПРИЛОЖЕНИЕ А

Диаграмма классов системы управления туристическим агентством

(Здесь должна быть UML-диаграмма классов, показывающая иерархию наследования TouristService и связи между классами Country, Hotel, Room, TransportCompany, Tour, Order, DataContainer, FileManager, StreamFileManager и MainWindow)


ПРИЛОЖЕНИЕ Б

Блок-схема алгоритма формирования тура с автоматическим расчетом стоимости

(Здесь должна быть блок-схема, иллюстрирующая процесс создания тура от ввода данных до автоматического расчета стоимости и связывания с отелями и транспортными компаниями)


ПРИЛОЖЕНИЕ В

Блок-схема алгоритма поиска туров по критериям

(Здесь должна быть блок-схема, показывающая процесс фильтрации туров с использованием STL-алгоритма std::copy_if и трех режимов фильтрации для каждого критерия)


ПРИЛОЖЕНИЕ Г

Структура файлов данных системы

countries.txt — формат хранения информации о странах:
```
COUNTRIES
[количество записей]
[название страны]
[континент]
[столица]
[валюта]
...
```

hotels.txt — формат хранения информации об отелях:
```
HOTELS
[количество записей]
[название отеля]
[страна]
[количество звезд]
[адрес]
[количество номеров]
  [название номера]
  [тип номера: 0-Single, 1-Double, 2-Suite, 3-Apartment]
  [вместимость]
  [цена за ночь]
  ...
```

transport_companies.txt — формат хранения информации о транспортных компаниях:
```
TRANSPORT_COMPANIES
[количество записей]
[название компании]
[тип транспорта: 0-Airplane, 1-Bus, 2-Train, 3-Ship]
[количество рейсов]
  [город отправления]
  [город прибытия]
  [дата отправления: дд.мм.гггг]
  [дата прибытия: дд.мм.гггг]
  [стоимость]
  [доступные места]
  ...
```

tours.txt — формат хранения информации о турах:
```
TOURS
[количество записей]
[название тура]
[страна]
[дата начала: дд.мм.гггг]
[дата окончания: дд.мм.гггг]
[данные отеля...]
[данные транспортной компании...]
```

orders.txt — формат хранения информации о заказах:
```
ORDERS
[количество записей]
[имя клиента]
[телефон клиента]
[дата заказа: дд.мм.гггг чч:мм:сс]
[статус]
[данные тура...]
```

