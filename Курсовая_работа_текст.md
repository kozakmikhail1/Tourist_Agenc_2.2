ВВЕДЕНИЕ

В современном мире туризм является одной из наиболее динамично развивающихся отраслей экономики. С ростом мобильности населения и расширением возможностей для путешествий растет и потребность в эффективных системах управления туристическими услугами. Туристические агентства ежедневно обрабатывают большое количество запросов от клиентов, управляют информацией о странах, отелях, транспортных компаниях, формируют туры и обрабатывают заказы. Ручное ведение таких процессов не только трудоемко, но и подвержено ошибкам, что может привести к неудовлетворенности клиентов и финансовым потерям.

Разработка автоматизированной системы управления туристическим агентством призвана решить эти проблемы, предлагая комплексное решение для управления всеми аспектами деятельности агентства. Система должна обеспечивать эффективное управление базой данных о странах, отелях, транспортных компаниях, формирование туристических пакетов с автоматическим расчетом стоимости, а также обработку заказов клиентов. Это позволит сотрудникам агентства сосредоточиться на работе с клиентами, а не на рутинных операциях с данными.

Анализ существующих решений на рынке показывает наличие множества программных продуктов для управления туристическими агентствами. Эти системы варьируются от простых приложений для учета клиентов до сложных ERP-систем, включающих интеграцию с глобальными системами бронирования (GDS). Однако многие из существующих решений либо слишком сложны и дороги для небольших агентств, либо не покрывают все необходимые функции, что создает потребность в разработке специализированного решения.

Разрабатываемый проект представляет собой настольное приложение для управления туристическим агентством, которое поможет автоматизировать процессы управления странами, отелями, транспортными компаниями, турами и заказами. Система будет включать функции категоризации стран по континентам, управления отелями с указанием количества номеров и их характеристик, управления транспортными компаниями с расписанием рейсов, формирования туров с автоматическим расчетом стоимости на основе выбранных услуг, а также управления заказами клиентов с отслеживанием их статуса.

1 ОБЗОР ЛИТЕРАТУРЫ

1.1 Система управления туристическим агентством как проект

Программное обеспечение для управления туристическим агентством включает несколько ключевых компонентов: клиентская часть с графическим интерфейсом, система хранения данных и бизнес-логика для обработки операций. В рамках данного проекта планируется реализация настольного приложения, которое будет работать с локальным хранилищем данных без использования серверной части. Клиентская часть выполняет следующие функции:

‒ Управление базой данных стран: добавление, редактирование и удаление информации о странах, включая континент, столицу и валюту.

‒ Управление базой данных отелей: ведение информации об отелях, их местоположении, категории (количество звезд), адресе и доступных номерах с характеристиками.

‒ Управление транспортными компаниями: ведение информации о компаниях, типе транспорта (самолет, поезд, автобус, корабль) и расписании рейсов с указанием городов отправления и прибытия, дат и стоимости.

‒ Формирование туров: создание туристических пакетов, включающих выбор страны, отеля, транспортной компании и дат поездки с автоматическим расчетом стоимости на основе выбранных услуг.

‒ Управление заказами: обработка заказов клиентов, включая регистрацию персональных данных клиента, выбор тура, расчет общей стоимости и отслеживание статуса заказа (в обработке, подтвержден, оплачен, завершен, отменен).

‒ Поиск туров: предоставление функционала для поиска туров по различным критериям, таким как страна, стоимость и продолжительность.

Для хранения данных используется файловая система с текстовыми файлами в структурированном формате, что позволяет эффективно управлять информацией о всех сущностях системы на локальном компьютере без необходимости подключения к удаленной базе данных.

1.2 Анализ существующих аналогов

На рынке программного обеспечения для туристических агентств существует множество решений, предназначенных как для крупных туроператоров, так и для небольших агентств. Рассмотрим несколько популярных систем, которые могут служить аналогами в контексте управления туристическим агентством.

1.2.1 TravelWorks

TravelWorks — это комплексная система управления туристическим агентством, используемая многими агентствами в России и странах СНГ. Система предоставляет функционал для управления клиентами, турами, заказами и финансовыми операциями. Программа интегрируется с системами бронирования и позволяет автоматизировать многие процессы в работе агентства.

Основные функции:

‒ Управление базой данных клиентов и заказов.

‒ Формирование туров и расчет стоимости.

‒ Интеграция с системами бронирования отелей и транспорта.

‒ Генерация отчетов и документов.

‒ Управление финансами и оплатой.

Преимущества:

‒ Широкая функциональность, покрывающая все аспекты работы агентства.

‒ Интеграция с внешними системами бронирования.

‒ Поддержка работы с документами и отчетностью.

Недостатки:

‒ Высокая стоимость лицензии и сложность настройки.

‒ Требует обучения сотрудников и значительных ресурсов для внедрения.

‒ Избыточный функционал для небольших агентств.

1.2.2 TourOperator

TourOperator — это специализированная система для управления туристическими агентствами, разработанная для автоматизации процессов продажи туров и работы с клиентами. Система предоставляет базовые функции для управления турами, заказами и клиентской базой. Программа может работать в локальном режиме и не требует постоянного подключения к интернету для базовых операций.

Основные функции:

‒ Управление каталогом туров.

‒ Обработка заказов клиентов.

‒ Ведение базы данных клиентов.

‒ Расчет стоимости туров.

‒ Генерация документов для клиентов.

Преимущества:

‒ Простота использования и интуитивно понятный интерфейс.

‒ Возможность работы в оффлайн-режиме.

‒ Доступная стоимость для небольших агентств.

Недостатки:

‒ Ограниченный функционал по сравнению с более сложными системами.

‒ Отсутствие интеграции с системами бронирования.

‒ Ограниченные возможности масштабирования.

1.2.3 Amadeus Selling Platform

Amadeus Selling Platform — это профессиональная система управления туристическим агентством, используемая крупными туроператорами и агентствами по всему миру. Система предоставляет доступ к глобальной системе бронирования Amadeus и включает функционал для управления заказами, клиентами и финансовыми операциями. Программа работает в онлайн-режиме и требует подключения к серверу Amadeus.

Основные функции:

‒ Интеграция с глобальной системой бронирования Amadeus.

‒ Управление заказами и бронированиями.

‒ Работа с клиентской базой.

‒ Финансовое управление и отчетность.

‒ Доступ к актуальной информации о турах, отелях и транспорте.

Преимущества:

‒ Доступ к актуальной информации о турах и услугах в режиме реального времени.

‒ Интеграция с крупнейшей системой бронирования.

‒ Мощный функционал для крупных агентств.

Недостатки:

‒ Очень высокая стоимость лицензии и абонентской платы.

‒ Требует постоянного подключения к интернету.

‒ Сложность настройки и обучения персонала.

‒ Не подходит для небольших агентств из-за высокой стоимости.

1.3 Используемые технологии

Для реализации проекта будут использованы следующие технологии и инструменты:

C++ — язык программирования, который будет использоваться для реализации всей бизнес-логики системы управления туристическим агентством. C++ обеспечивает высокую производительность при работе с большими объемами данных и позволяет эффективно реализовать объектно-ориентированную архитектуру приложения. Язык поддерживает такие концепции, как наследование, полиморфизм, шаблоны и перегрузку операторов, что необходимо для создания гибкой и расширяемой системы.

Qt — кроссплатформенный фреймворк для создания графического пользовательского интерфейса. Qt предоставляет богатый набор виджетов для создания интуитивно понятного интерфейса, включая таблицы для отображения данных, диалоговые окна для ввода информации, меню и панели инструментов. Фреймворк также обеспечивает удобную работу с файлами, что необходимо для хранения данных в текстовом формате. Qt поддерживает сигналы и слоты для реализации событийно-ориентированного программирования, что упрощает создание интерактивного интерфейса.

Объектно-ориентированное программирование — подход к программированию, основанный на концепциях классов и объектов. В рамках проекта будет реализована иерархия классов для представления туристических услуг: базовый класс TouristService, от которого наследуются классы Country, Hotel, TransportCompany и Tour. Это позволит реализовать полиморфизм и обеспечить единообразную работу с различными типами услуг. Класс Order будет представлять заказ клиента и связывать его с выбранным туром.

Шаблоны и контейнеры — для управления коллекциями объектов будут использованы шаблонные классы и STL-контейнеры. Будет реализован собственный шаблонный контейнер DataContainer, который обеспечит типобезопасное хранение и управление объектами различных типов (Country, Hotel, TransportCompany, Tour, Order). Контейнер будет поддерживать итераторы для удобного обхода элементов и использования STL-алгоритмов.

Файловая система — для хранения данных будет использована файловая система с текстовыми файлами в структурированном формате. Каждый тип сущностей (страны, отели, транспортные компании, туры, заказы) будет храниться в отдельном файле. Для работы с файлами будет реализован класс FileManager, который обеспечит загрузку данных из файлов при запуске приложения и сохранение изменений при выходе. Такой подход обеспечивает простоту реализации и возможность ручного редактирования данных при необходимости.

1.4 Постановка задачи

Целью работы является создание настольного приложения для управления туристическим агентством с функциями управления странами, отелями, транспортными компаниями, турами и заказами. Программа будет иметь графический интерфейс, разработанный с использованием Qt, и систему хранения данных на основе текстовых файлов для управления информацией о всех сущностях системы.

Задачи, которые необходимо реализовать:

Управление странами:

‒ Добавление, редактирование и удаление информации о странах.

‒ Хранение информации о стране: название, континент, столица, валюта.

‒ Просмотр списка стран с возможностью сортировки и фильтрации.

Управление отелями:

‒ Добавление, редактирование и удаление информации об отелях.

‒ Хранение информации об отеле: название, страна, категория (количество звезд), адрес.

‒ Управление номерами в отеле: добавление номеров с указанием типа, вместимости и стоимости за ночь.

‒ Просмотр списка отелей с отображением количества доступных номеров.

Управление транспортными компаниями:

‒ Добавление, редактирование и удаление информации о транспортных компаниях.

‒ Хранение информации о компании: название, тип транспорта (самолет, поезд, автобус, корабль).

‒ Управление расписанием рейсов: добавление рейсов с указанием городов отправления и прибытия, дат, стоимости и количества доступных мест.

‒ Просмотр списка транспортных компаний с информацией о количестве рейсов.

Формирование туров:

‒ Создание туров на основе выбранной страны, отеля, транспортной компании и дат поездки.

‒ Автоматический расчет стоимости тура на основе стоимости транспорта и стоимости проживания в отеле (цена за ночь × количество ночей).

‒ Связывание туров с отелями и транспортными компаниями для обеспечения целостности данных.

‒ Просмотр списка туров с информацией о стране, датах и стоимости.

Управление заказами:

‒ Создание заказов на основе выбранного тура и данных клиента (имя, телефон).

‒ Автоматический расчет общей стоимости заказа на основе стоимости выбранного тура.

‒ Отслеживание статуса заказа (в обработке, подтвержден, оплачен, завершен, отменен).

‒ Изменение статуса заказа в процессе обработки.

‒ Просмотр списка заказов с информацией о клиенте, туре, стоимости и статусе.

Поиск туров:

‒ Реализация функционала поиска туров по различным критериям.

‒ Поиск по стране: фильтрация туров по выбранной стране или исключение определенных стран.

‒ Поиск по стоимости: фильтрация туров по максимальной стоимости.

‒ Поиск по продолжительности: фильтрация туров по минимальной продолжительности.

‒ Комбинированный поиск с применением нескольких критериев одновременно.

Хранение данных:

‒ Использование текстовых файлов для хранения информации о странах, отелях, транспортных компаниях, турах и заказах.

‒ Реализация загрузки данных из файлов при запуске приложения.

‒ Реализация сохранения данных в файлы при закрытии приложения или по запросу пользователя.

‒ Обеспечение целостности данных при выполнении операций.

Интерфейс пользователя:

‒ Создание графического интерфейса с использованием Qt с вкладками для различных типов сущностей (Страны, Отели, Транспортные компании, Туры, Заказы).

‒ Реализация таблиц для отображения списков сущностей с возможностью сортировки по различным столбцам.

‒ Создание диалоговых окон для добавления и редактирования сущностей.

‒ Реализация контекстных меню и кнопок для выполнения операций (добавить, редактировать, удалить).

‒ Обеспечение интуитивно понятного и удобного интерфейса для работы с системой.

Программа должна обеспечивать выполнение всех основных функций системы управления туристическим агентством с возможностью управления всеми типами сущностей, формирования туров с автоматическим расчетом стоимости и обработки заказов клиентов.

2 ФУНКЦИОНАЛЬНОЕ ПРОЕКТИРОВАНИЕ

Проект включает в себя несколько ключевых функций, которые обеспечат эффективное управление туристическим агентством, автоматизацию процессов формирования туров и обработки заказов. Основные возможности включают в себя:

Возможность управления базой данных стран, отелей и транспортных компаний с добавлением, редактированием и удалением записей.

Функция формирования туров с автоматическим расчетом стоимости на основе выбранных услуг (отель, транспорт) и дат поездки. Все рейсы отправляются из Минска (Беларусь).

Автоматическое связывание туров с отелями и транспортными компаниями на основе страны назначения и дат поездки для обеспечения целостности данных.

Функции для создания и обработки заказов клиентов с отслеживанием статуса заказа и автоматическим расчетом общей стоимости.

Возможность поиска туров по различным критериям (страна, стоимость, продолжительность) с применением фильтров и исключений.

Сохранение и загрузка данных о всех сущностях системы в текстовых файлах с обеспечением целостности данных при выполнении операций.

Использование объектно-ориентированного подхода с иерархией классов для представления туристических услуг и обеспечения полиморфизма при работе с различными типами данных.

Для более детального понимания архитектуры проекта используется диаграмма классов (Приложение А), которая визуализирует структуру системы и взаимосвязи между основными компонентами. Эта диаграмма помогает увидеть, как данные перемещаются через систему, как различные классы взаимодействуют друг с другом, и как реализована иерархия наследования для туристических услуг.

2.1 Описание функции формирования тура с автоматическим расчетом стоимости

Функция формирования тура является одной из ключевых функций системы, позволяющей создавать туристические пакеты на основе выбранных услуг и автоматически рассчитывать их стоимость. Эта функция разработана с учетом необходимости обеспечения корректности данных, валидации входных параметров и автоматического вычисления итоговой стоимости тура.

Процесс формирования тура начинается с выбора пользователем базовых параметров: названия тура, страны назначения, дат начала и окончания поездки. Система проверяет корректность введенных данных, включая валидность дат (дата окончания должна быть позже даты начала) и наличие выбранной страны в базе данных. Если какой-либо параметр не проходит проверку, процесс формирования тура останавливается с генерацией соответствующего сообщения об ошибке.

После успешной проверки базовых параметров пользователь выбирает отель из списка доступных отелей в выбранной стране. Система автоматически фильтрует список отелей, отображая только те, которые расположены в выбранной стране. При выборе отеля пользователь также выбирает конкретный номер из доступных номеров отеля, каждый из которых имеет свой тип (одноместный, двухместный, люкс и т.д.), вместимость и стоимость за ночь.

Далее пользователь выбирает транспортную компанию и конкретный рейс из расписания. Система также автоматически фильтрует транспортные компании, отображая только те, которые имеют рейсы в города выбранной страны. При фильтрации учитываются столица страны, города из адресов отелей, а также известные туристические города (например, для ОАЭ учитываются как столица Абу-Даби, так и Дубай). Система проверяет, чтобы дата рейса была не позже даты начала тура.

После выбора всех компонентов тура система автоматически рассчитывает его стоимость. Расчет выполняется по следующей формуле: стоимость тура = стоимость транспорта + (стоимость номера за ночь × количество ночей). Количество ночей вычисляется как разница между датой окончания и датой начала тура. Стоимость транспорта берется из выбранного рейса, а стоимость проживания рассчитывается на основе выбранного номера в отеле и продолжительности тура.

Особенностью реализации является использование виртуальной функции calculateCost() из базового класса TouristService, которая переопределена в классе Tour. Это обеспечивает полиморфизм и позволяет единообразно работать с различными типами туристических услуг. Расчет стоимости выполняется динамически при каждом обращении, что гарантирует актуальность данных даже при изменении цен на услуги.

После формирования тура система автоматически связывает его с выбранными отелем и транспортной компанией, сохраняя ссылки на эти объекты внутри объекта тура. Это обеспечивает целостность данных и позволяет в дальнейшем автоматически обновлять информацию о туре при изменении данных об отеле или транспорте.

Данная функция является важным компонентом проекта, обеспечивая автоматизацию процесса создания туров и исключая возможность ошибок при ручном расчете стоимости. Она позволяет сотрудникам агентства быстро формировать туристические пакеты и предоставлять клиентам точную информацию о стоимости поездки.

2.2 Описание функции управления заказами

Функция управления заказами отвечает за создание, обработку и отслеживание заказов клиентов в системе. Она выполняет несколько ключевых операций для обеспечения корректного процесса работы с заказами от момента их создания до завершения.

Процесс создания заказа начинается с выбора тура из списка доступных туров или формирования нового тура непосредственно при создании заказа. Система проверяет наличие выбранного тура в базе данных и его валидность (наличие названия, страны, корректных дат). Если тур не найден или содержит некорректные данные, процесс создания заказа останавливается с указанием причины.

После выбора тура пользователь вводит данные клиента: имя и контактный телефон. Система проверяет, что обязательные поля заполнены и не пусты. Если какое-либо поле не проходит проверку, создание заказа блокируется. Это позволяет избежать создания заказов с неполными данными, что может привести к проблемам при дальнейшей работе с клиентом.

После успешной проверки данных создается новый объект заказа, которому автоматически присваивается уникальный идентификатор. Идентификатор генерируется автоматически с использованием статической переменной, что гарантирует его уникальность. Заказу присваивается начальный статус "В обработке", а дата создания заказа устанавливается как текущая дата и время.

Одной из ключевых особенностей функции является автоматический расчет общей стоимости заказа на основе стоимости выбранного тура. Расчет выполняется через вызов метода calculateCost() объекта тура, что обеспечивает актуальность стоимости даже при изменении данных о туре. Если тур в заказе не имеет связанных отеля и транспортной компании, система автоматически пытается связать их на основе страны тура и дат поездки, используя функцию linkOrdersToursWithHotelsAndTransport().

Функция обработки заказа позволяет изменять статус заказа в процессе его обработки. Доступны следующие статусы: "В обработке", "Подтвержден", "Оплачен", "Завершен", "Отменен". При изменении статуса система проверяет, что новый статус отличается от текущего, и обновляет информацию о заказе. Это позволяет отслеживать жизненный цикл заказа от момента создания до завершения или отмены.

Функция редактирования заказа позволяет изменять данные клиента (имя, телефон) и выбранный тур. При изменении тура система автоматически пересчитывает стоимость заказа и обновляет связи тура с отелями и транспортом. Это обеспечивает актуальность данных заказа даже при изменении его параметров.

Все операции с заказами выполняются с проверкой целостности данных. При удалении заказа система проверяет его существование и запрашивает подтверждение у пользователя. При отображении заказов в таблице система фильтрует заказы с пустыми данными (отсутствие названия тура, имени клиента или телефона), что обеспечивает отображение только валидных записей.

Таким образом, функция управления заказами предоставляет комплексный инструмент для работы с заказами клиентов, объединяя создание, обработку, отслеживание статуса и обеспечение целостности данных. Она является неотъемлемой частью системы управления туристическим агентством, повышая эффективность работы с клиентами и обеспечивая прозрачность процессов.

2.3 Описание функции поиска туров

Функция поиска туров предназначена для предоставления пользователям возможности находить туры, соответствующие заданным критериям. Эта функция реализована с использованием STL-алгоритмов и обеспечивает гибкую фильтрацию туров по различным параметрам с возможностью комбинирования нескольких критериев.

Процесс поиска начинается с получения критериев фильтрации от пользователя. Система поддерживает три основных критерия поиска: по стране, по максимальной стоимости и по минимальной продолжительности. Для каждого критерия пользователь может выбрать одно из трех состояний: "Не применять" (критерий игнорируется), "Фильтровать" (включать только туры, соответствующие критерию) или "Исключить" (исключать туры, соответствующие критерию).

Фильтр по стране работает на основе текстового поиска с учетом регистра. Пользователь вводит название страны или его часть, и система проверяет, содержится ли эта строка в названии страны тура. При выборе режима "Фильтровать" в результаты поиска попадают только туры, страна которых содержит введенный текст. При выборе режима "Исключить" из результатов исключаются туры, страна которых содержит указанный текст. Это позволяет, например, найти все туры в Европу, исключив определенные страны.

Фильтр по стоимости работает на основе максимального значения. Пользователь указывает максимальную стоимость тура, и система сравнивает рассчитанную стоимость каждого тура с этим значением. При режиме "Фильтровать" в результаты попадают только туры со стоимостью, не превышающей указанное значение. При режиме "Исключить" из результатов исключаются туры со стоимостью, не превышающей указанное значение, что позволяет найти более дорогие туры.

Фильтр по продолжительности работает на основе минимального количества дней. Система вычисляет продолжительность каждого тура как разницу между датой окончания и датой начала поездки. При режиме "Фильтровать" в результаты попадают только туры с продолжительностью, не меньшей указанного значения. При режиме "Исключить" из результатов исключаются туры с продолжительностью, не меньшей указанного значения.

Особенностью реализации является использование STL-алгоритма std::copy_if для фильтрации туров. Алгоритм применяет предикат (лямбда-функцию) к каждому туру в контейнере и копирует в результирующий контейнер только те туры, для которых предикат возвращает true. Предикат проверяет все три критерия фильтрации последовательно, применяя логику каждого критерия в зависимости от его состояния. Это обеспечивает эффективную фильтрацию больших объемов данных.

После фильтрации результаты автоматически сортируются по стоимости по возрастанию с использованием STL-алгоритма std::sort. Это позволяет пользователю видеть наиболее доступные туры в начале списка. Сортировка выполняется на основе вычисленной стоимости тура через метод calculateCost().

Результаты поиска отображаются в таблице, которая показывает название тура, страну, даты начала и окончания, а также стоимость. Для правильной числовой сортировки стоимости используется специальный класс NumericSortItem, который хранит числовое значение отдельно от текстового представления, что обеспечивает корректную сортировку по числовому значению, а не по алфавиту.

Функция также обеспечивает валидацию входных данных. Проверяется корректность введенных значений (например, стоимость не может быть отрицательной, продолжительность должна быть положительным числом). Если обнаруживаются некорректные данные, система отображает соответствующее сообщение, но не прерывает процесс поиска, применяя только валидные критерии.

Таким образом, функция поиска туров предоставляет мощный и гибкий инструмент для нахождения туров, соответствующих требованиям пользователя. Она объединяет фильтрацию по нескольким критериям, автоматическую сортировку результатов и удобное отображение информации, что делает процесс поиска туров быстрым и эффективным.

2.4 Описание функции связывания туров с отелями и транспортными компаниями

Функция связывания туров с отелями и транспортными компаниями обеспечивает автоматическое установление связей между турами и соответствующими услугами на основе страны назначения и дат поездки. Эта функция является важным компонентом системы, обеспечивающим целостность данных и корректность расчета стоимости туров.

Процесс связывания начинается с перебора всех туров в системе. Для каждого тура система извлекает информацию о стране назначения и дате начала поездки. На основе страны тура система определяет столицу страны, используя данные из базы стран. Столица используется как один из целевых городов для поиска подходящих рейсов.

Далее система собирает все возможные целевые города для поиска транспорта. В этот набор включаются столица страны, города из адресов отелей, расположенных в выбранной стране, а также известные туристические города (например, для ОАЭ учитываются как столица Абу-Даби, так и Дубай). Это обеспечивает гибкость при поиске подходящих рейсов, так как рейсы могут прибывать в различные города страны.

Для каждого тура система ищет подходящий отель среди отелей, расположенных в стране тура. Отель считается подходящим, если он находится в той же стране, что и тур, и имеет хотя бы один доступный номер. При нахождении подходящего отеля система связывает его с туром, сохраняя объект отеля внутри объекта тура.

После связывания отеля система ищет подходящий рейс среди всех транспортных компаний. Для каждой транспортной компании система перебирает все рейсы в ее расписании. Рейс считается подходящим, если город прибытия совпадает с одним из целевых городов (с учетом частичного совпадения и без учета регистра), а дата отправления рейса не позже даты начала тура. Система проверяет как точное совпадение городов, так и частичное (например, если рейс прибывает в "Дубай", а целевой город "Дубай-Маррина"), что повышает вероятность нахождения подходящего рейса.

Особенностью реализации является использование множества (QSet) для хранения целевых городов, что обеспечивает быстрый поиск и исключает дубликаты. При проверке совпадения городов система использует сравнение без учета регистра и проверяет как точное совпадение, так и вхождение одной строки в другую, что позволяет находить рейсы даже при незначительных различиях в написании названий городов.

После нахождения подходящего рейса система связывает его с туром, сохраняя как объект транспортной компании, так и объект расписания рейса внутри объекта тура. Это позволяет в дальнейшем использовать эту информацию для расчета стоимости тура и отображения детальной информации о транспорте.

Функция также обрабатывает специальные случаи. Например, для стран с несколькими популярными туристическими городами (таких как ОАЭ) система учитывает все известные города при поиске рейсов. Если у тура отсутствуют валидные даты, система устанавливает даты по умолчанию (текущая дата и дата через неделю), что позволяет корректно рассчитать стоимость даже для туров с неполными данными.

Для заказов реализована дополнительная логика связывания. Система сначала пытается найти полный тур по названию и стране в списке туров. Если такой тур найден, используются его данные, включая связи с отелем и транспортом. Если полный тур не найден, система применяет ту же логику автоматического связывания, что и для обычных туров.

Данная функция вызывается автоматически при загрузке данных из файлов, при создании или редактировании туров и заказов, а также при удалении туров. Это обеспечивает актуальность связей между сущностями и гарантирует, что все туры имеют корректно связанные отели и транспортные компании для правильного расчета стоимости.

Таким образом, функция связывания туров с отелями и транспортными компаниями является важным компонентом системы, обеспечивающим автоматизацию установления связей между сущностями и гарантирующим целостность данных. Она упрощает процесс работы с турами и исключает необходимость ручного связывания услуг, что повышает эффективность работы системы и снижает вероятность ошибок.

3 РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ

3.1 Описание программных модулей

1 Класс: TouristService.

Абстрактный базовый класс для всех туристических услуг. Обеспечивает единый интерфейс для работы с различными типами услуг через механизм виртуальных функций и полиморфизма.

Поля:

‒ name_ (QString): название услуги.

‒ price_ (double): базовая цена услуги.

Методы:

‒ TouristService(const QString& name, double price): конструктор, устанавливающий название и цену услуги.

‒ virtual ~TouristService(): виртуальный деструктор для корректного уничтожения объектов производных классов.

‒ getName() const: возвращает название услуги.

‒ setName(const QString& name): устанавливает название услуги.

‒ getPrice() const: возвращает базовую цену услуги.

‒ setPrice(double price): устанавливает базовую цену услуги.

‒ virtual QString getType() const = 0: чистая виртуальная функция, возвращающая тип услуги. Должна быть реализована в производных классах.

‒ virtual QString getDescription() const = 0: чистая виртуальная функция, возвращающая описание услуги. Должна быть реализована в производных классах.

‒ virtual double calculateCost() const: виртуальная функция расчета стоимости с реализацией по умолчанию, возвращающая базовую цену.

‒ virtual void writeToStream(std::ostream& os) const: виртуальная функция для записи в поток.

‒ virtual void readFromStream(std::istream& is): виртуальная функция для чтения из потока.

2 Класс: Country.

Представляет страну как туристическое направление. Наследуется от TouristService. Хранит информацию о стране: название, континент, столицу и валюту.

Поля:

‒ continent_ (QString): континент, на котором расположена страна.

‒ capital_ (QString): столица страны.

‒ currency_ (QString): валюта страны.

Методы:

‒ Country(const QString& name, const QString& continent): конструктор, устанавливающий название и континент.

‒ QString getType() const override: возвращает тип "Country".

‒ QString getDescription() const override: возвращает описание страны.

‒ QString getContinent() const: возвращает континент.

‒ void setContinent(const QString& continent): устанавливает континент.

‒ QString getCapital() const: возвращает столицу.

‒ void setCapital(const QString& capital): устанавливает столицу.

‒ QString getCurrency() const: возвращает валюту.

‒ void setCurrency(const QString& currency): устанавливает валюту.

‒ bool operator==(const Country& other) const: оператор сравнения на равенство.

‒ bool operator!=(const Country& other) const: оператор сравнения на неравенство.

‒ Country& operator=(const Country& other): оператор присваивания.

‒ friend std::ostream& operator<<(std::ostream& os, const Country& country): дружественная функция для вывода в поток.

‒ friend std::istream& operator>>(std::istream& is, Country& country): дружественная функция для ввода из потока.

‒ void writeToFile(std::ofstream& ofs) const: запись данных страны в файл.

‒ void readFromFile(std::ifstream& ifs): чтение данных страны из файла.

3 Класс: Room.

Представляет номер в отеле. Наследуется от TouristService. Хранит информацию о типе номера, его вместимости и стоимости за ночь.

Поля:

‒ roomType_ (RoomType): тип номера (одноместный, двухместный, люкс, апартаменты).

‒ capacity_ (int): вместимость номера (количество человек).

‒ pricePerNight_ (double): стоимость номера за ночь.

Методы:

‒ Room(const QString& name, RoomType type, double pricePerNight, int capacity): конструктор номера.

‒ QString getType() const override: возвращает тип "Room".

‒ QString getDescription() const override: возвращает описание номера.

‒ RoomType getRoomType() const: возвращает тип номера.

‒ void setRoomType(RoomType type): устанавливает тип номера.

‒ int getCapacity() const: возвращает вместимость номера.

‒ void setCapacity(int capacity): устанавливает вместимость номера.

‒ double getPricePerNight() const: возвращает стоимость за ночь.

‒ void setPricePerNight(double price): устанавливает стоимость за ночь.

‒ static QString roomTypeToString(RoomType type): преобразует тип номера в строку.

‒ static RoomType stringToRoomType(const QString& str): преобразует строку в тип номера.

4 Класс: Hotel.

Представляет отель как туристическую услугу. Наследуется от TouristService. Хранит информацию об отеле: название, страну, категорию (количество звезд), адрес и список номеров.

Поля:

‒ country_ (QString): страна, в которой расположен отель.

‒ stars_ (int): категория отеля (количество звезд).

‒ address_ (QString): адрес отеля.

‒ rooms_ (QVector<Room>): вектор номеров отеля.

Методы:

‒ Hotel(const QString& name, const QString& country, int stars, const QString& address): конструктор отеля.

‒ QString getType() const override: возвращает тип "Hotel".

‒ QString getDescription() const override: возвращает описание отеля.

‒ double calculateCost() const override: переопределенная функция расчета стоимости, суммирует стоимость всех номеров.

‒ QString getCountry() const: возвращает страну отеля.

‒ void setCountry(const QString& country): устанавливает страну отеля.

‒ int getStars() const: возвращает категорию отеля.

‒ void setStars(int stars): устанавливает категорию отеля.

‒ QString getAddress() const: возвращает адрес отеля.

‒ void setAddress(const QString& address): устанавливает адрес отеля.

‒ void addRoom(const Room& room): добавляет номер в отель.

‒ void removeRoom(int index): удаляет номер по индексу.

‒ QVector<Room> getRooms() const: возвращает все номера отеля.

‒ Room* getRoom(int index): возвращает указатель на номер по индексу.

‒ const Room* getRoom(int index) const: возвращает константный указатель на номер по индексу.

‒ int getRoomCount() const: возвращает количество номеров в отеле.

5 Класс: TransportSchedule.

Структура, представляющая расписание рейса транспортной компании. Хранит информацию о городе отправления, городе прибытия, датах отправления и прибытия, стоимости и количестве доступных мест.

Поля:

‒ departureCity (QString): город отправления.

‒ arrivalCity (QString): город прибытия.

‒ departureDate (QDate): дата отправления.

‒ arrivalDate (QDate): дата прибытия.

‒ price (double): стоимость рейса.

‒ availableSeats (int): количество доступных мест.

6 Класс: TransportCompany.

Представляет транспортную компанию как туристическую услугу. Наследуется от TouristService. Хранит информацию о компании: название, тип транспорта (самолет, поезд, автобус, корабль) и расписание рейсов.

Поля:

‒ transportType_ (TransportType): тип транспорта.

‒ schedules_ (QVector<TransportSchedule>): вектор расписаний рейсов.

Методы:

‒ TransportCompany(const QString& name, TransportType type): конструктор транспортной компании.

‒ QString getType() const override: возвращает тип "TransportCompany".

‒ QString getDescription() const override: возвращает описание транспортной компании.

‒ TransportType getTransportType() const: возвращает тип транспорта.

‒ void setTransportType(TransportType type): устанавливает тип транспорта.

‒ void addSchedule(const TransportSchedule& schedule): добавляет рейс в расписание.

‒ void removeSchedule(int index): удаляет рейс по индексу.

‒ QVector<TransportSchedule> getSchedules() const: возвращает все расписания рейсов.

‒ TransportSchedule* getSchedule(int index): возвращает указатель на расписание по индексу.

‒ int getScheduleCount() const: возвращает количество рейсов в расписании.

‒ static QString transportTypeToString(TransportType type): преобразует тип транспорта в строку.

‒ static TransportType stringToTransportType(const QString& str): преобразует строку в тип транспорта.

7 Класс: Tour.

Представляет тур как комплексную туристическую услугу. Наследуется от TouristService. Хранит информацию о туре: название, страну назначения, даты начала и окончания, связанный отель, транспортную компанию и расписание рейса. Хранит объекты Hotel и TransportCompany по значению, что обеспечивает целостность данных тура даже при изменении исходных объектов.

Поля:

‒ country_ (QString): страна назначения тура.

‒ startDate_ (QDate): дата начала тура.

‒ endDate_ (QDate): дата окончания тура.

‒ hotel_ (Hotel): отель, связанный с туром (хранится по значению).

‒ transportCompany_ (TransportCompany): транспортная компания, связанная с туром (хранится по значению).

‒ transportSchedule_ (TransportSchedule): расписание рейса для тура.

Методы:

‒ Tour(const QString& name, const QString& country, const QDate& startDate, const QDate& endDate): конструктор тура.

‒ QString getType() const override: возвращает тип "Tour".

‒ QString getDescription() const override: возвращает описание тура.

‒ double calculateCost() const override: переопределенная функция расчета стоимости тура на основе стоимости транспорта и стоимости проживания в отеле.

‒ QString getCountry() const: возвращает страну назначения.

‒ void setCountry(const QString& country): устанавливает страну назначения.

‒ QDate getStartDate() const: возвращает дату начала тура.

‒ void setStartDate(const QDate& date): устанавливает дату начала тура.

‒ QDate getEndDate() const: возвращает дату окончания тура.

‒ void setEndDate(const QDate& date): устанавливает дату окончания тура.

‒ int getDuration() const: возвращает продолжительность тура в днях.

‒ void setHotel(const Hotel& hotel): устанавливает отель для тура (копирует объект).

‒ Hotel getHotel() const: возвращает копию отеля тура.

‒ Hotel* getHotelPtr(): возвращает указатель на отель тура для модификации.

‒ void setTransportCompany(const TransportCompany& company): устанавливает транспортную компанию для тура (копирует объект).

‒ TransportCompany getTransportCompany() const: возвращает копию транспортной компании тура.

‒ TransportCompany* getTransportCompanyPtr(): возвращает указатель на транспортную компанию тура для модификации.

‒ void setTransportSchedule(const TransportSchedule& schedule): устанавливает расписание рейса для тура.

‒ TransportSchedule getTransportSchedule() const: возвращает расписание рейса для тура.

8 Класс: Order.

Представляет заказ клиента на туристический тур. Хранит информацию о заказе: уникальный идентификатор, связанный тур, данные клиента (имя, телефон), дату создания заказа и статус обработки.

Поля:

‒ nextId_ (static int): статическая переменная для генерации уникальных идентификаторов заказов.

‒ id_ (int): уникальный идентификатор заказа.

‒ tour_ (Tour): тур, на который оформлен заказ.

‒ clientName_ (QString): имя клиента.

‒ clientPhone_ (QString): телефон клиента.

‒ orderDate_ (QDateTime): дата и время создания заказа.

‒ status_ (QString): статус заказа (В обработке, Подтвержден, Оплачен, Завершен, Отменен).

Методы:

‒ Order(): конструктор по умолчанию, создает заказ с автоматически сгенерированным идентификатором.

‒ Order(const Tour& tour, const QString& clientName, const QString& clientPhone): конструктор заказа с параметрами.

‒ int getId() const: возвращает идентификатор заказа.

‒ Tour getTour() const: возвращает тур заказа.

‒ void setTour(const Tour& tour): устанавливает тур для заказа.

‒ QString getClientName() const: возвращает имя клиента.

‒ void setClientName(const QString& name): устанавливает имя клиента.

‒ QString getClientPhone() const: возвращает телефон клиента.

‒ void setClientPhone(const QString& phone): устанавливает телефон клиента.

‒ QDateTime getOrderDate() const: возвращает дату создания заказа.

‒ void setOrderDate(const QDateTime& date): устанавливает дату создания заказа.

‒ double getTotalCost() const: возвращает общую стоимость заказа на основе стоимости тура.

‒ QString getStatus() const: возвращает статус заказа.

‒ void setStatus(const QString& status): устанавливает статус заказа.

‒ QString toString() const: возвращает строковое представление заказа.

‒ bool operator==(const Order& other) const: оператор сравнения на равенство по идентификатору.

‒ bool operator!=(const Order& other) const: оператор сравнения на неравенство.

‒ bool operator<(const Order& other) const: оператор сравнения для сортировки по стоимости.

‒ friend std::ostream& operator<<(std::ostream& os, const Order& order): дружественная функция для вывода в поток.

‒ friend std::istream& operator>>(std::istream& is, Order& order): дружественная функция для ввода из потока.

‒ void writeToFile(std::ofstream& ofs) const: запись данных заказа в файл.

‒ void readFromFile(std::ifstream& ifs): чтение данных заказа из файла.

9 Класс: ContainerIterator.

Шаблонный класс итератора для контейнера DataContainer. Реализует функциональность random access iterator, позволяя использовать STL-алгоритмы для работы с контейнером.

Поля:

‒ ptr_ (typename QVector<T>::iterator): итератор вектора Qt, используемый для доступа к элементам.

Методы:

‒ ContainerIterator(): конструктор по умолчанию.

‒ explicit ContainerIterator(typename QVector<T>::iterator it): конструктор с параметром итератора.

‒ reference operator*() const: оператор разыменования, возвращает ссылку на элемент.

‒ pointer operator->() const: оператор доступа к членам, возвращает указатель на элемент.

‒ ContainerIterator& operator++(): префиксный оператор инкремента.

‒ ContainerIterator operator++(int): постфиксный оператор инкремента.

‒ ContainerIterator& operator--(): префиксный оператор декремента.

‒ ContainerIterator operator--(int): постфиксный оператор декремента.

‒ ContainerIterator& operator+=(difference_type n): оператор добавления смещения.

‒ ContainerIterator& operator-=(difference_type n): оператор вычитания смещения.

‒ ContainerIterator operator+(difference_type n) const: оператор сложения итератора и смещения.

‒ ContainerIterator operator-(difference_type n) const: оператор вычитания смещения из итератора.

‒ difference_type operator-(const ContainerIterator& other) const: оператор вычисления расстояния между итераторами.

‒ bool operator==(const ContainerIterator& other) const: оператор сравнения на равенство.

‒ bool operator!=(const ContainerIterator& other) const: оператор сравнения на неравенство.

‒ bool operator<(const ContainerIterator& other) const: оператор сравнения "меньше".

‒ bool operator>(const ContainerIterator& other) const: оператор сравнения "больше".

‒ bool operator<=(const ContainerIterator& other) const: оператор сравнения "меньше или равно".

‒ bool operator>=(const ContainerIterator& other) const: оператор сравнения "больше или равно".

10 Класс: DataContainer.

Шаблонный контейнер для хранения данных различных типов. Обеспечивает типобезопасное хранение и управление объектами. Использует QVector для внутреннего хранения и предоставляет итераторы для использования STL-алгоритмов.

Поля:

‒ data_ (QVector<T>): вектор Qt для хранения элементов контейнера.

Методы:

‒ DataContainer(): конструктор по умолчанию.

‒ ~DataContainer(): деструктор.

‒ void add(const T& item): добавляет элемент в контейнер.

‒ void remove(int index): удаляет элемент по индексу.

‒ void remove(const T& item): удаляет элемент по значению.

‒ T* get(int index): возвращает указатель на элемент по индексу.

‒ const T* get(int index) const: возвращает константный указатель на элемент по индексу.

‒ int size() const: возвращает количество элементов в контейнере.

‒ bool isEmpty() const: проверяет, пуст ли контейнер.

‒ void clear(): очищает контейнер.

‒ Iterator begin(): возвращает итератор на начало контейнера.

‒ Iterator end(): возвращает итератор на конец контейнера.

‒ ConstIterator begin() const: возвращает константный итератор на начало контейнера.

‒ ConstIterator end() const: возвращает константный итератор на конец контейнера.

‒ ConstIterator cbegin() const: возвращает константный итератор на начало контейнера.

‒ ConstIterator cend() const: возвращает константный итератор на конец контейнера.

‒ QVector<T>& getData(): возвращает ссылку на внутренний вектор.

‒ const QVector<T>& getData() const: возвращает константную ссылку на внутренний вектор.

‒ template<typename Predicate> Iterator findIf(Predicate pred): находит первый элемент, удовлетворяющий предикату.

‒ template<typename Predicate> ConstIterator findIf(Predicate pred) const: находит первый элемент, удовлетворяющий предикату (константная версия).

‒ template<typename Predicate> bool removeIf(Predicate pred): удаляет первый элемент, удовлетворяющий предикату.

11 Класс: FileManager.

Менеджер для работы с файлами данных. Обеспечивает сохранение и загрузку данных о странах, отелях, транспортных компаниях, турах и заказах в текстовые файлы. Использует кодировку UTF-8 для корректной работы с кириллицей.

Поля:

‒ dataPath_ (QString): путь к директории с данными.

Методы:

‒ FileManager(): конструктор, создающий директорию данных, если она не существует.

‒ void saveCountries(const DataContainer<Country>& countries, const QString& filename) const: сохраняет страны в файл.

‒ void saveHotels(const DataContainer<Hotel>& hotels, const QString& filename) const: сохраняет отели в файл.

‒ void saveTransportCompanies(const DataContainer<TransportCompany>& companies, const QString& filename) const: сохраняет транспортные компании в файл.

‒ void saveTours(const DataContainer<Tour>& tours, const QString& filename) const: сохраняет туры в файл.

‒ void saveOrders(const DataContainer<Order>& orders, const QString& filename) const: сохраняет заказы в файл.

‒ void loadCountries(DataContainer<Country>& countries, const QString& filename) const: загружает страны из файла.

‒ void loadHotels(DataContainer<Hotel>& hotels, const QString& filename) const: загружает отели из файла.

‒ void loadTransportCompanies(DataContainer<TransportCompany>& companies, const QString& filename) const: загружает транспортные компании из файла.

‒ void loadTours(DataContainer<Tour>& tours, const QString& filename) const: загружает туры из файла.

‒ void loadOrders(DataContainer<Order>& orders, const QString& filename) const: загружает заказы из файла.

‒ void saveAll(const DataContainer<Country>& countries, const DataContainer<Hotel>& hotels, const DataContainer<TransportCompany>& companies, const DataContainer<Tour>& tours, const DataContainer<Order>& orders, const QString& basePath) const: сохраняет все данные в файлы.

‒ void loadAll(DataContainer<Country>& countries, DataContainer<Hotel>& hotels, DataContainer<TransportCompany>& companies, DataContainer<Tour>& tours, DataContainer<Order>& orders, const QString& basePath) const: загружает все данные из файлов.

12 Класс: FileException.

Исключение, возникающее при ошибке работы с файлами. Наследуется от std::exception.

Методы:

‒ FileException(const QString& message): конструктор, принимающий сообщение об ошибке.

‒ const char* what() const noexcept override: возвращает сообщение об ошибке.

13 Класс: StreamFileManager.

Менеджер для работы с файлами через стандартные потоки C++. Обеспечивает альтернативный способ сохранения и загрузки данных о странах и заказах с использованием потоков std::ifstream и std::ofstream. Демонстрирует работу с файловыми потоками и перегрузку операторов ввода/вывода.

Поля:

‒ basePath_ (std::string): путь к директории с данными.

Методы:

‒ StreamFileManager(const std::string& basePath): конструктор, принимающий базовый путь к данным.

‒ void saveCountries(const DataContainer<Country>& countries, const std::string& filename) const: сохраняет страны в файл через потоки.

‒ void saveOrders(const DataContainer<Order>& orders, const std::string& filename) const: сохраняет заказы в файл через потоки.

‒ void loadCountries(DataContainer<Country>& countries, const std::string& filename) const: загружает страны из файла через потоки.

‒ void loadOrders(DataContainer<Order>& orders, const std::string& filename) const: загружает заказы из файла через потоки.

‒ void saveAll(const DataContainer<Country>& countries, const DataContainer<Order>& orders, const std::string& basePath) const: сохраняет все данные через потоки.

‒ void loadAll(DataContainer<Country>& countries, DataContainer<Order>& orders, const std::string& basePath) const: загружает все данные через потоки.

‒ void ensureDirectoryExists(const std::string& path) const: вспомогательный метод для создания директории, если она не существует.

14 Класс: StreamFileException.

Исключение, возникающее при ошибке работы с файлами через потоки. Наследуется от std::exception.

Методы:

‒ StreamFileException(const std::string& message): конструктор, принимающий сообщение об ошибке.

‒ const char* what() const noexcept override: возвращает сообщение об ошибке.

15 Класс: NumericSortItem.

Кастомный класс для числовой сортировки в QTableWidget. Хранит числовое значение отдельно от текстового представления, что обеспечивает корректную числовую сортировку, а не алфавитную.

Поля:

‒ numericValue_ (double): числовое значение для сортировки.

Методы:

‒ NumericSortItem(const QString& text, double numericValue): конструктор, принимающий текстовое представление и числовое значение.

‒ bool operator<(const QTableWidgetItem& other) const override: переопределенный оператор сравнения для числовой сортировки.

‒ QVariant data(int role) const override: переопределенная функция для возврата данных, включая числовое значение в UserRole.

16 Класс: MainWindow.

Главное окно приложения. Реализует графический интерфейс пользователя с использованием Qt. Управляет всеми данными системы через контейнеры и обеспечивает взаимодействие пользователя с системой. Использует паттерн Command для инкапсуляции операций через классы Action и вспомогательные классы для управления таблицами и фильтрами.

Поля:

‒ ui (std::unique_ptr<Ui::MainWindow>): умный указатель на объект пользовательского интерфейса.

‒ countries_ (DataContainer<Country>): контейнер для хранения стран.

‒ hotels_ (DataContainer<Hotel>): контейнер для хранения отелей.

‒ transportCompanies_ (DataContainer<TransportCompany>): контейнер для хранения транспортных компаний.

‒ tours_ (DataContainer<Tour>): контейнер для хранения туров.

‒ orders_ (DataContainer<Order>): контейнер для хранения заказов.

‒ fileManager_ (FileManager): менеджер для работы с файлами.

‒ networkManager_ (QNetworkAccessManager*): менеджер для работы с сетевыми запросами (обновление курсов валют).

‒ currencyTimer_ (QTimer*): таймер для периодического обновления курсов валют.

‒ tableManager_ (TableManager*): указатель на менеджер таблиц для обновления и управления таблицами.

‒ filterManager_ (FilterManager*): указатель на менеджер фильтров для применения фильтрации к таблицам.

‒ filterComboUpdater_ (FilterComboUpdater*): указатель на обновлятель комбобоксов фильтров.

‒ actions_ (QMap<QString, Action*>): карта действий (Command pattern) для выполнения операций с данными.

Методы:

‒ MainWindow(QWidget* parent): конструктор главного окна. Инициализирует все компоненты интерфейса, создает вспомогательные классы и инициализирует действия.

‒ ~MainWindow(): деструктор главного окна. Освобождает ресурсы и удаляет вспомогательные объекты.

‒ void setupUI(): настройка пользовательского интерфейса.

‒ void setupMenuBar(): настройка меню приложения.

‒ void setupStatusBar(): настройка строки состояния.

‒ void setupTables(): настройка таблиц для отображения данных.

‒ void setupControlsAdaptivity(): настройка адаптивности элементов управления.

‒ void updateTablesFontSize(): обновление размера шрифта в таблицах.

‒ void initializeActions(): инициализация всех действий (Command pattern) и добавление их в карту действий.

‒ void updateCountriesTable(): обновление таблицы стран через TableManager.

‒ void updateHotelsTable(): обновление таблицы отелей через TableManager.

‒ void updateTransportCompaniesTable(): обновление таблицы транспортных компаний через TableManager.

‒ void updateToursTable(): обновление таблицы туров через TableManager.

‒ void updateOrdersTable(): обновление таблицы заказов через TableManager.

‒ void saveData(): сохранение всех данных в файлы.

‒ void loadData(): загрузка всех данных из файлов с валидацией и обработкой ошибок.

‒ void onTabChanged(int index): обработчик изменения вкладки.

‒ void onCountriesHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы стран для трехрежимной сортировки.

‒ void onHotelsHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы отелей для трехрежимной сортировки.

‒ void onTransportHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы транспортных компаний для трехрежимной сортировки.

‒ void onToursHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы туров для трехрежимной сортировки.

‒ void onOrdersHeaderClicked(int logicalIndex): обработчик клика по заголовку таблицы заказов для трехрежимной сортировки.

‒ void updateCurrencyRates(): обновление курсов валют через сетевой запрос.

‒ void onCurrencyDataReceived(QNetworkReply* reply): обработчик получения данных о курсах валют.

‒ int getSelectedCountryIndex() const: получение реального индекса выбранной страны в контейнере.

‒ int getSelectedHotelIndex() const: получение реального индекса выбранного отеля в контейнере.

‒ int getSelectedTransportIndex() const: получение реального индекса выбранной транспортной компании в контейнере.

‒ int getSelectedTourIndex() const: получение реального индекса выбранного тура в контейнере.

‒ int getSelectedOrderIndex() const: получение реального индекса выбранного заказа в контейнере.

‒ void linkToursWithHotelsAndTransport(): автоматическое связывание туров с отелями и транспортными компаниями.

‒ void linkOrdersToursWithHotelsAndTransport(): автоматическое связывание туров в заказах с отелями и транспортными компаниями.

‒ QString findCountryCapital(const QString& countryName) const: вспомогательная функция для поиска столицы страны.

‒ QSet<QString> collectTargetCities(const QString& tourCountry, const QString& capital) const: сбор целевых городов для поиска транспорта.

‒ Hotel* findHotelForTour(const QString& tourCountry): поиск подходящего отеля для тура.

‒ bool matchesCity(const QString& arrivalCity, const QSet<QString>& targetCities, const QString& capital, const QString& tourCountry) const: проверка совпадения города прибытия с целевыми городами.

‒ bool findTransportForTour(Tour& tour, const QSet<QString>& targetCities, const QString& capital, const QDate& tourStartDate): поиск подходящего транспорта для тура.

‒ QString findDataDirectory() const: поиск директории с данными.

‒ bool validateDataDirectory(const QString& dataPath): валидация директории с данными.

‒ QStringList checkRequiredFiles(const QString& dataPath): проверка наличия необходимых файлов данных.

‒ void clearAllData(): очистка всех данных из контейнеров.

‒ LoadResult loadAllDataFiles(const QString& dataPath): загрузка всех файлов данных с возвратом результата.

‒ void showLoadResults(const LoadResult& result, const QString& dataPath): отображение результатов загрузки данных.

‒ QWidget* createActionButtons(int dataIndex, const QString& type): создание виджета с кнопками действий для строки таблицы.

‒ void updateCountriesFilterCombo(): обновление комбобокса фильтра стран через FilterComboUpdater.

‒ void updateHotelsFilterCombos(): обновление комбобоксов фильтров отелей через FilterComboUpdater.

‒ void updateTransportFilterCombo(): обновление комбобокса фильтра транспортных компаний через FilterComboUpdater.

‒ void updateToursFilterCombo(): обновление комбобокса фильтра туров через FilterComboUpdater.

‒ void updateOrdersFilterCombo(): обновление комбобокса фильтра заказов через FilterComboUpdater.

‒ void setupCurrencyUpdater(): настройка системы автоматического обновления курсов валют.

17 Класс: Action.

Базовый абстрактный класс для реализации паттерна Command. Используется для инкапсуляции операций с данными в виде объектов, что позволяет реализовать единообразный интерфейс для выполнения различных действий (добавление, редактирование, удаление, просмотр информации).

Поля:

‒ отсутствуют (базовый класс).

Методы:

‒ Action(QObject* parent = nullptr): конструктор базового класса действий.

‒ virtual ~Action(): виртуальный деструктор.

‒ virtual void execute() = 0: чистая виртуальная функция выполнения действия. Должна быть реализована в производных классах.

‒ virtual void undo(): виртуальная функция отмены действия с пустой реализацией по умолчанию. Может быть переопределена в производных классах для поддержки отмены операций.

‒ virtual QString description() const = 0: чистая виртуальная функция, возвращающая описание действия.

Сигналы:

‒ void executed(): сигнал, испускаемый после выполнения действия.

18 Класс: AddCountryAction, EditCountryAction, DeleteCountryAction, ShowCountryInfoAction, RefreshCountriesAction.

Производные классы от Action для выполнения операций со странами. Каждый класс инкапсулирует конкретную операцию (добавление, редактирование, удаление, просмотр информации, обновление таблицы) и выполняет её при вызове метода execute().

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.

‒ table_ (QTableWidget*): указатель на таблицу для отображения данных.

‒ parent_ (QWidget*): указатель на родительский виджет для диалогов.

Методы:

‒ Конструкторы принимают указатели на контейнер данных, таблицу и родительский виджет.

‒ void execute() override: переопределенная функция выполнения действия, открывающая соответствующий диалог или выполняющая операцию.

‒ QString description() const override: возвращает описание действия.

19 Класс: AddHotelAction, EditHotelAction, DeleteHotelAction, ShowHotelInfoAction, RefreshHotelsAction.

Производные классы от Action для выполнения операций с отелями. Аналогичны классам для работы со странами, но работают с контейнером отелей.

20 Класс: AddTransportCompanyAction, EditTransportCompanyAction, DeleteTransportCompanyAction, ShowTransportCompanyInfoAction, RefreshTransportCompaniesAction.

Производные классы от Action для выполнения операций с транспортными компаниями. Аналогичны классам для работы со странами, но работают с контейнером транспортных компаний.

21 Класс: AddTourAction, EditTourAction, DeleteTourAction, ShowTourInfoAction, SearchToursAction, RefreshToursAction.

Производные классы от Action для выполнения операций с турами. Включают дополнительный класс SearchToursAction для открытия диалога поиска туров.

22 Класс: AddOrderAction, EditOrderAction, ProcessOrderAction, DeleteOrderAction, ShowOrderInfoAction, RefreshOrdersAction.

Производные классы от Action для выполнения операций с заказами. Включают класс ProcessOrderAction для изменения статуса заказа.

23 Класс: BookTourCostCalculator.

Вспомогательный класс для расчета стоимости тура при бронировании. Инкапсулирует логику расчета стоимости транспорта, проживания в отеле и общей стоимости тура с учетом различных множителей (категория отеля, страна назначения).

Поля:

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.

‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.

‒ uiElements_ (BookTourUIElements): структура с указателями на элементы интерфейса для получения выбранных значений.

Методы:

‒ BookTourCostCalculator(DataContainer<Hotel>* hotels, DataContainer<TransportCompany>* companies, const BookTourUIElements& uiElements): конструктор, принимающий контейнеры данных и элементы интерфейса.

‒ double calculateTotalCost() const: вычисляет общую стоимость тура.

‒ double calculateTransportCost() const: вычисляет стоимость транспорта.

‒ double calculateHotelCost() const: вычисляет стоимость проживания в отеле.

‒ int calculateNights() const: вычисляет количество ночей на основе выбранных дат.

‒ double getStarMultiplier(int stars) const: возвращает множитель стоимости в зависимости от категории отеля (количество звезд).

‒ double getCountryMultiplier(const QString& country) const: возвращает множитель стоимости в зависимости от страны назначения.

24 Класс: TourSetupHelper.

Вспомогательный класс для настройки тура в диалоге. Обеспечивает автоматическое заполнение полей диалога при редактировании тура и поиск существующих туров.

Поля:

‒ countries_ (DataContainer<Country>*): указатель на контейнер со странами.

‒ hotels_ (DataContainer<Hotel>*): указатель на контейнер с отелями.

‒ companies_ (DataContainer<TransportCompany>*): указатель на контейнер с транспортными компаниями.

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами.

Методы:

‒ TourSetupHelper(DataContainer<Country>* countries, DataContainer<Hotel>* hotels, DataContainer<TransportCompany>* companies, DataContainer<Tour>* tours): конструктор, принимающий указатели на все контейнеры данных.

‒ bool findExistingTour(const Tour& tour, int& tourIndex) const: находит существующий тур в контейнере и возвращает его индекс.

‒ void setupTransportAndSchedule(const Tour& tour, QComboBox* countryCombo, QComboBox* transportCombo, QComboBox* scheduleCombo) const: настраивает комбобоксы транспорта и расписания на основе данных тура.

‒ void setupHotelAndRoom(const Tour& tour, QComboBox* countryCombo, QComboBox* hotelCombo, QComboBox* roomCombo) const: настраивает комбобоксы отеля и номера на основе данных тура.

‒ Hotel getSelectedHotel(const QString& country, QComboBox* countryCombo, QComboBox* hotelCombo, QComboBox* roomCombo) const: получает выбранный отель из комбобоксов.

‒ void setupTourTransport(Tour& tour, QComboBox* countryCombo, QComboBox* transportCombo, QComboBox* scheduleCombo) const: настраивает транспорт для тура на основе выбранных значений в комбобоксах.

25 Класс: FilterManager.

Вспомогательный класс для управления фильтрацией данных в таблицах. Инкапсулирует логику применения фильтров к различным типам таблиц, что упрощает код класса MainWindow.

Поля:

‒ отсутствуют (все методы статические или используют только параметры).

Методы:

‒ FilterManager(): конструктор по умолчанию.

‒ void applyCountriesFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* continentCombo, QComboBox* currencyCombo): применяет фильтры к таблице стран.

‒ void applyHotelsFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* countryCombo, QComboBox* starsCombo): применяет фильтры к таблице отелей.

‒ void applyTransportFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* typeCombo): применяет фильтры к таблице транспортных компаний.

‒ void applyToursFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* countryCombo, QLineEdit* minPriceEdit, QLineEdit* maxPriceEdit): применяет фильтры к таблице туров.

‒ void applyOrdersFilters(QTableWidget* table, QLineEdit* searchEdit, QComboBox* statusCombo, QLineEdit* minCostEdit, QLineEdit* maxCostEdit): применяет фильтры к таблице заказов.

‒ bool matchesSearchText(QTableWidget* table, int row, const QString& searchText) const: проверяет, соответствует ли строка таблицы тексту поиска.

‒ double extractCostFromItem(QTableWidgetItem* item) const: извлекает числовое значение стоимости из элемента таблицы.

26 Класс: TableManager.

Вспомогательный класс для управления таблицами. Инкапсулирует логику обновления таблиц и получения выбранных элементов, что упрощает код класса MainWindow.

Поля:

‒ отсутствуют (все методы используют только параметры).

Методы:

‒ TableManager(): конструктор по умолчанию.

‒ void updateCountriesTable(QTableWidget* table, const DataContainer<Country>& countries): обновляет таблицу стран.

‒ void updateHotelsTable(QTableWidget* table, const DataContainer<Hotel>& hotels): обновляет таблицу отелей.

‒ void updateTransportCompaniesTable(QTableWidget* table, const DataContainer<TransportCompany>& companies): обновляет таблицу транспортных компаний.

‒ void updateToursTable(QTableWidget* table, const DataContainer<Tour>& tours): обновляет таблицу туров.

‒ void updateOrdersTable(QTableWidget* table, const DataContainer<Order>& orders): обновляет таблицу заказов.

‒ int getSelectedRow(QTableWidget* table) const: возвращает индекс выбранной строки в таблице.

‒ int getSelectedIndex(QTableWidget* table, int column) const: возвращает реальный индекс элемента в контейнере на основе выбранной строки таблицы.

27 Класс: FilterComboUpdater.

Вспомогательный класс для обновления комбобоксов фильтров. Автоматически заполняет комбобоксы уникальными значениями из данных для удобной фильтрации.

Поля:

‒ отсутствуют (все методы используют только параметры).

Методы:

‒ FilterComboUpdater(): конструктор по умолчанию.

‒ void updateCountriesFilterCombo(QComboBox* combo, const DataContainer<Country>& countries): обновляет комбобокс фильтра стран.

‒ void updateHotelsFilterCombos(QComboBox* countryCombo, QComboBox* starsCombo, const DataContainer<Hotel>& hotels, const DataContainer<Country>& countries): обновляет комбобоксы фильтров отелей.

‒ void updateTransportFilterCombo(QComboBox* combo, const DataContainer<TransportCompany>& companies): обновляет комбобокс фильтра транспортных компаний.

‒ void updateToursFilterCombo(QComboBox* combo, const DataContainer<Tour>& tours, const DataContainer<Country>& countries): обновляет комбобокс фильтра туров.

‒ void updateOrdersFilterCombo(QComboBox* combo, const DataContainer<Order>& orders): обновляет комбобокс фильтра заказов.

28 Класс: SearchDialog.

Диалоговое окно для поиска туров по заданным критериям. Позволяет фильтровать туры по стране, максимальной стоимости и минимальной продолжительности с использованием STL-алгоритмов.

Поля:

‒ ui (Ui::SearchDialog*): указатель на объект пользовательского интерфейса.

‒ tours_ (DataContainer<Tour>*): указатель на контейнер с турами для поиска.

Методы:

‒ SearchDialog(QWidget* parent, DataContainer<Tour>* tours): конструктор диалога поиска.

‒ ~SearchDialog(): деструктор.

‒ void search(): выполнение поиска туров по критериям с использованием std::copy_if.

‒ void onResultSelected(): обработчик выбора результата из таблицы.

‒ void updateResultsTable(const QVector<Tour>& results): обновление таблицы результатов поиска.

29 Класс: CountryDialog.

Диалоговое окно для добавления и редактирования информации о стране.

Поля:

‒ ui (Ui::CountryDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ CountryDialog(QWidget* parent): конструктор диалога.

‒ ~CountryDialog(): деструктор.

‒ void setCountry(const Country& country): установка данных страны для редактирования.

‒ Country getCountry() const: получение данных введенной или измененной страны.

30 Класс: HotelDialog.

Диалоговое окно для добавления и редактирования информации об отеле.

Поля:

‒ ui (Ui::HotelDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ HotelDialog(QWidget* parent, const DataContainer<Country>* countries): конструктор диалога с доступом к списку стран.

‒ ~HotelDialog(): деструктор.

‒ void setHotel(const Hotel& hotel): установка данных отеля для редактирования.

‒ Hotel getHotel() const: получение данных введенного или измененного отеля.

31 Класс: CompanyDialog.

Диалоговое окно для добавления и редактирования информации о транспортной компании.

Поля:

‒ ui (Ui::CompanyDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ CompanyDialog(QWidget* parent): конструктор диалога.

‒ ~CompanyDialog(): деструктор.

‒ void setTransportCompany(const TransportCompany& company): установка данных компании для редактирования.

‒ TransportCompany getTransportCompany() const: получение данных введенной или измененной компании.

32 Класс: RoomDialog.

Диалоговое окно для добавления и редактирования информации о номере отеля.

Поля:

‒ ui (Ui::RoomDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ RoomDialog(QWidget* parent): конструктор диалога.

‒ ~RoomDialog(): деструктор.

‒ void setRoom(const Room& room): установка данных номера для редактирования.

‒ Room getRoom() const: получение данных введенного или измененного номера.

33 Класс: ScheduleDialog.

Диалоговое окно для добавления и редактирования расписания рейса транспортной компании.

Поля:

‒ ui (Ui::ScheduleDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ ScheduleDialog(QWidget* parent): конструктор диалога.

‒ ~ScheduleDialog(): деструктор.

‒ void setSchedule(const TransportSchedule& schedule): установка данных расписания для редактирования.

‒ TransportSchedule getSchedule() const: получение данных введенного или измененного расписания.

34 Класс: TourDialog.

Диалоговое окно для добавления и редактирования информации о туре.

Поля:

‒ ui (Ui::TourDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ TourDialog(QWidget* parent, const DataContainer<Country>* countries): конструктор диалога с доступом к списку стран.

‒ ~TourDialog(): деструктор.

‒ void setTour(const Tour& tour): установка данных тура для редактирования.

‒ Tour getTour() const: получение данных введенного или измененного тура.

35 Класс: BookTourDialog.

Диалоговое окно для бронирования тура (создания заказа).

Поля:

‒ ui (Ui::BookTourDialog*): указатель на объект пользовательского интерфейса.

Методы:

‒ BookTourDialog(QWidget* parent, const DataContainer<Tour>* tours): конструктор диалога с доступом к списку туров.

‒ ~BookTourDialog(): деструктор.

‒ void setOrder(const Order& order): установка данных заказа для редактирования.

‒ Order getOrder() const: получение данных введенного или измененного заказа.

3.2 Примеры кода

3.2.1 Функция расчета стоимости тура

Функция calculateCost() класса Tour разработана с использованием следующих принципов:

Полиморфизм: Переопределение виртуальной функции calculateCost() из базового класса TouristService обеспечивает возможность вычисления стоимости различных типов услуг единообразным способом.

Инкапсуляция: Логика расчета стоимости инкапсулирована внутри класса Tour, что скрывает детали реализации от внешнего кода.

Динамический расчет: Стоимость рассчитывается динамически на основе актуальных данных о транспорте и отеле, что гарантирует актуальность результата.

Основные фрагменты кода:

1 Переопределение виртуальной функции

double Tour::calculateCost() const {
    double totalCost = 0.0;
    
    // Стоимость транспорта
    totalCost += transportSchedule_.price;
    
    // Стоимость отеля (цена за ночь * количество ночей)
    int nights = getDuration();
    if (nights > 0 && hotel_.getRoomCount() > 0) {
        auto rooms = hotel_.getRooms();
        if (!rooms.isEmpty()) {
            totalCost += rooms.first().getPricePerNight() * nights;
        }
    }
    
    return totalCost;
}

Этот фрагмент демонстрирует переопределение виртуальной функции calculateCost() из базового класса TouristService. Функция вычисляет общую стоимость тура как сумму стоимости транспорта и стоимости проживания в отеле. Стоимость транспорта берется из расписания рейса, а стоимость проживания рассчитывается как произведение цены номера за ночь на количество ночей, вычисляемое через функцию getDuration().

2 Вычисление продолжительности тура

int Tour::getDuration() const {
    if (!startDate_.isValid() || !endDate_.isValid()) {
        return 0;
    }
    return startDate_.daysTo(endDate_);
}

Эта функция вычисляет продолжительность тура в днях как разницу между датой окончания и датой начала. Перед вычислением выполняется проверка валидности дат, что предотвращает ошибки при работе с некорректными данными.

3 Использование полиморфизма

Tour tempTour = getTour();
double totalCost = tempTour.calculateCost();

В этом фрагменте демонстрируется использование полиморфизма: объект Tour используется через базовый интерфейс TouristService, но вызывается переопределенная версия функции calculateCost(), что обеспечивает корректный расчет стоимости именно для тура.

3.2.2 Функция связывания туров с отелями и транспортными компаниями

Функция linkToursWithHotelsAndTransport() реализована с учетом следующих принципов:

Автоматизация: Функция автоматически находит подходящие отели и транспортные компании для каждого тура на основе страны назначения и дат поездки.

Гибкость: Используется множество (QSet) для хранения целевых городов, что позволяет учитывать различные варианты городов назначения (столица, города отелей, известные туристические города).

Надежность: Проверка совпадения городов выполняется с учетом частичного совпадения и без учета регистра, что повышает вероятность нахождения подходящего рейса.

Ключевые фрагменты кода и их описание:

1 Поиск столицы страны

QString capital = "";
for (const auto& country : countries_.getData()) {
    if (country.getName() == tourCountry) {
        capital = country.getCapital();
        break;
    }
}

Этот блок кода находит столицу страны тура, перебирая все страны в контейнере и сравнивая их названия. Столица используется как один из целевых городов для поиска подходящих рейсов.

2 Сбор целевых городов

QSet<QString> targetCities;
if (!capital.isEmpty()) {
    targetCities.insert(capital);
}

// Ищем отель по стране тура и собираем города отелей
Hotel* selectedHotel = nullptr;
for (auto& hotel : hotels_.getData()) {
    if (hotel.getCountry() == tourCountry && hotel.getRoomCount() > 0) {
        QString address = hotel.getAddress();
        if (!address.isEmpty()) {
            QString city = address.split(',').first().trimmed();
            if (!city.isEmpty()) {
                targetCities.insert(city);
            }
        }
        
        if (!selectedHotel) {
            selectedHotel = &hotel;
        }
    }
}

Этот фрагмент собирает все возможные целевые города для поиска транспорта. В множество добавляются столица страны и города из адресов отелей, расположенных в стране тура. Одновременно выполняется поиск подходящего отеля, который должен находиться в стране тура и иметь хотя бы один номер.

3 Поиск подходящего рейса

bool cityMatches = false;
if (!targetCities.isEmpty()) {
    QString arrivalCityLower = arrivalCity.toLower();
    for (const QString& targetCity : targetCities) {
        QString targetCityLower = targetCity.toLower();
        if (arrivalCity == targetCity || 
            arrivalCityLower == targetCityLower ||
            arrivalCityLower.contains(targetCityLower) ||
            targetCityLower.contains(arrivalCityLower)) {
            cityMatches = true;
            break;
        }
    }
}

bool dateMatches = !tourStartDate.isValid() || 
                  !scheduleDepartureDate.isValid() ||
                  scheduleDepartureDate <= tourStartDate;

if (cityMatches && (dateMatches || !tourStartDate.isValid())) {
    tour.setTransportCompany(company);
    tour.setTransportSchedule(*schedule);
    foundSchedule = true;
    break;
}

Этот блок кода выполняет поиск подходящего рейса для тура. Проверяется совпадение города прибытия с одним из целевых городов (с учетом частичного совпадения и без учета регистра) и соответствие даты отправления рейса дате начала тура (рейс должен быть не позже даты начала тура). При нахождении подходящего рейса он связывается с туром.

4 Обработка специальных случаев

if (!cityMatches && tourCountry == "ОАЭ") {
    QString arrivalCityLower = arrivalCity.toLower();
    if (arrivalCityLower.contains("дубай") || arrivalCityLower.contains("абу-даби") || 
        arrivalCityLower.contains("abu dhabi") || arrivalCityLower.contains("dubai")) {
        cityMatches = true;
    }
}

Этот фрагмент обрабатывает специальные случаи, такие как страны с несколькими популярными туристическими городами. Для ОАЭ учитываются как столица (Абу-Даби), так и популярный туристический город (Дубай), что повышает вероятность нахождения подходящего рейса.

3.2.3 Функция поиска туров

Функция search() класса SearchDialog реализована с использованием следующих принципов:

Использование STL-алгоритмов: Применение алгоритма std::copy_if обеспечивает эффективную фильтрацию больших объемов данных.

Гибкая фильтрация: Поддержка трех режимов для каждого критерия (не применять, фильтровать, исключить) позволяет комбинировать различные условия поиска.

Лямбда-функции: Использование лямбда-функций в качестве предикатов обеспечивает компактность и читаемость кода.

Ключевые фрагменты кода и их описание:

1 Фильтрация туров с использованием STL-алгоритмов

std::copy_if(tours_->getData().begin(), tours_->getData().end(),
             std::back_inserter(results),
             [countryFilter, maxCost, minDuration, countryFilterState, costFilterState, durationFilterState](const Tour& tour) {
    // Фильтр по стране
    if (countryFilterState == 1) { // Фильтровать
        if (countryFilter.isEmpty() || 
            !tour.getCountry().contains(countryFilter, Qt::CaseInsensitive)) {
            return false;
        }
    } else if (countryFilterState == 2) { // Исключить
        if (!countryFilter.isEmpty() && 
            tour.getCountry().contains(countryFilter, Qt::CaseInsensitive)) {
            return false;
        }
    }
    
    // Фильтр по стоимости
    if (costFilterState == 1) { // Фильтровать
        if (tour.calculateCost() > maxCost) {
            return false;
        }
    } else if (costFilterState == 2) { // Исключить
        if (tour.calculateCost() <= maxCost) {
            return false;
        }
    }
    
    // Фильтр по продолжительности
    if (durationFilterState == 1) { // Фильтровать
        if (tour.getDuration() < minDuration) {
            return false;
        }
    } else if (durationFilterState == 2) { // Исключить
        if (tour.getDuration() >= minDuration) {
            return false;
        }
    }
    
    return true;
});

Этот фрагмент демонстрирует использование STL-алгоритма std::copy_if для фильтрации туров по заданным критериям. Лямбда-функция проверяет каждый тур на соответствие критериям фильтрации: по стране (текстовый поиск с учетом регистра), по стоимости (максимальное значение) и по продолжительности (минимальное значение). Для каждого критерия поддерживаются три режима: не применять (критерий игнорируется), фильтровать (включать только соответствующие туры) и исключить (исключать соответствующие туры).

2 Сортировка результатов

std::sort(results.begin(), results.end(),
          [](const Tour& a, const Tour& b) {
    return a.calculateCost() < b.calculateCost();
});

Этот фрагмент выполняет сортировку отфильтрованных туров по стоимости по возрастанию с использованием STL-алгоритма std::sort и лямбда-функции для сравнения. Сортировка выполняется на основе вычисленной стоимости тура через метод calculateCost(), что обеспечивает актуальность данных.

3 Использование NumericSortItem для числовой сортировки

double cost = tour.calculateCost();
NumericSortItem* costItem = new NumericSortItem(QString::number(cost, 'f', 2) + " руб", cost);
costItem->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter);
ui->resultsTable->setItem(row, 4, costItem);

Этот фрагмент демонстрирует использование класса NumericSortItem для корректной числовой сортировки стоимости туров в таблице. Класс хранит числовое значение отдельно от текстового представления, что обеспечивает сортировку по числовому значению, а не по алфавиту.

3.2.4 Функция загрузки данных из файлов

Функция loadCountries() класса FileManager реализована с учетом следующих принципов:

Обработка ошибок: Использование исключений для обработки ошибок чтения файлов обеспечивает надежную работу при некорректных данных.

Проверка формата: Валидация заголовка файла и количества записей предотвращает загрузку некорректных данных.

Кодировка UTF-8: Использование кодировки UTF-8 обеспечивает корректную работу с кириллицей.

Основные фрагменты кода:

1 Открытие файла и проверка формата

QFile file(filename);
if (!file.exists()) {
    qWarning() << "File does not exist:" << filename;
    return;
}

if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
    throw FileException(QString("Cannot open file for reading: %1").arg(filename));
}

QTextStream in(&file);
in.setEncoding(QStringConverter::Encoding::Utf8);

QString header = in.readLine();
if (header != "COUNTRIES") {
    throw FileException("Invalid file format");
}

int count = in.readLine().toInt();
if (count <= 0) {
    qWarning() << "Invalid count in countries file:" << count;
    return;
}

Этот блок кода открывает файл для чтения, устанавливает кодировку UTF-8, проверяет наличие файла и корректность его формата. Если файл не существует или имеет некорректный формат, функция выдает предупреждение или исключение, что предотвращает загрузку некорректных данных.

2 Загрузка данных

countries.clear();

for (int i = 0; i < count; ++i) {
    Country country;
    QString name = in.readLine();
    QString continent = in.readLine();
    QString capital = in.readLine();
    QString currency = in.readLine();
    
    if (name.isEmpty() || continent.isEmpty() || capital.isEmpty() || currency.isEmpty()) {
        throw FileException(QString("Incomplete data for country at index %1").arg(i));
    }
    
    country.setName(name);
    country.setContinent(continent);
    country.setCapital(capital);
    country.setCurrency(currency);
    countries.add(country);
}

Этот фрагмент загружает данные о странах из файла. Перед загрузкой контейнер очищается, затем для каждой записи создается объект Country, данные считываются из файла, выполняется проверка на полноту данных, и объект добавляется в контейнер. Если данные неполные, выбрасывается исключение с указанием индекса записи.

3.3 Разработка алгоритмов

Схема алгоритма формирования тура представлена в приложении Б, схема алгоритма поиска туров представлена в приложении В.

3.3.1 Алгоритм формирования тура с автоматическим расчетом стоимости

Шаг 1: Начало.

Шаг 2: Пользователь открывает диалог создания тура.

Шаг 3: Ввод названия тура и выбор страны назначения.

Шаг 4: Ввод дат начала и окончания поездки.

Шаг 5: Проверка корректности дат (дата окончания должна быть позже даты начала).

Шаг 6: Если даты некорректны, вывод сообщения об ошибке и переход к шагу 5.

Шаг 7: Фильтрация отелей по выбранной стране.

Шаг 8: Выбор отеля из списка доступных отелей.

Шаг 9: Выбор номера в отеле.

Шаг 10: Фильтрация транспортных компаний по стране назначения (столица, города отелей).

Шаг 11: Выбор транспортной компании.

Шаг 12: Фильтрация рейсов по дате отправления (рейс должен быть не позже даты начала тура).

Шаг 13: Выбор рейса из расписания.

Шаг 14: Вычисление продолжительности тура (разница между датой окончания и датой начала).

Шаг 15: Расчет стоимости транспорта из выбранного рейса.

Шаг 16: Расчет стоимости проживания (цена номера за ночь × количество ночей).

Шаг 17: Расчет общей стоимости тура (стоимость транспорта + стоимость проживания).

Шаг 18: Отображение стоимости тура в интерфейсе.

Шаг 19: Сохранение тура в контейнер.

Шаг 20: Автоматическое связывание тура с отелем и транспортной компанией.

Шаг 21: Обновление таблицы туров.

Шаг 22: Конец.

3.3.2 Алгоритм поиска туров по критериям

Шаг 1: Начало.

Шаг 2: Пользователь открывает диалог поиска туров.

Шаг 3: Ввод критериев поиска (страна, максимальная стоимость, минимальная продолжительность).

Шаг 4: Выбор режима для каждого критерия (не применять, фильтровать, исключить).

Шаг 5: Начало цикла по всем турам в контейнере.

Шаг 6: Проверка критерия по стране.

Шаг 7: Если режим "Фильтровать" и страна тура не содержит введенный текст, исключить тур из результатов.

Шаг 8: Если режим "Исключить" и страна тура содержит введенный текст, исключить тур из результатов.

Шаг 9: Проверка критерия по стоимости.

Шаг 10: Если режим "Фильтровать" и стоимость тура больше максимальной, исключить тур из результатов.

Шаг 11: Если режим "Исключить" и стоимость тура не больше максимальной, исключить тур из результатов.

Шаг 12: Проверка критерия по продолжительности.

Шаг 13: Если режим "Фильтровать" и продолжительность тура меньше минимальной, исключить тур из результатов.

Шаг 14: Если режим "Исключить" и продолжительность тура не меньше минимальной, исключить тур из результатов.

Шаг 15: Если тур прошел все проверки, добавить его в результаты.

Шаг 16: Переход к следующему туру (шаг 5).

Шаг 17: Сортировка результатов по стоимости по возрастанию.

Шаг 18: Отображение результатов в таблице.

Шаг 19: Конец.

3.3.3 Алгоритм автоматического связывания туров с отелями и транспортными компаниями

Шаг 1: Начало.

Шаг 2: Начало цикла по всем турам в контейнере.

Шаг 3: Получение страны назначения тура.

Шаг 4: Поиск столицы страны в контейнере стран.

Шаг 5: Создание множества целевых городов.

Шаг 6: Добавление столицы в множество целевых городов.

Шаг 7: Начало цикла по всем отелям в контейнере.

Шаг 8: Проверка, находится ли отель в стране тура и имеет ли номера.

Шаг 9: Если условие выполнено, извлечение города из адреса отеля.

Шаг 10: Добавление города в множество целевых городов.

Шаг 11: Сохранение первого подходящего отеля.

Шаг 12: Переход к следующему отелю (шаг 7).

Шаг 13: Установка найденного отеля для тура.

Шаг 14: Начало цикла по всем транспортным компаниям в контейнере.

Шаг 15: Начало цикла по всем рейсам транспортной компании.

Шаг 16: Получение города прибытия и даты отправления рейса.

Шаг 17: Проверка совпадения города прибытия с одним из целевых городов (с учетом частичного совпадения и без учета регистра).

Шаг 18: Если город не совпадает, проверка специальных случаев (например, ОАЭ: Абу-Даби и Дубай).

Шаг 19: Проверка соответствия даты отправления рейса дате начала тура (рейс должен быть не позже даты начала тура).

Шаг 20: Если город и дата совпадают, установка транспортной компании и расписания для тура.

Шаг 21: Выход из циклов.

Шаг 22: Переход к следующему туру (шаг 2).

Шаг 23: Конец.

3.4 Особенности работы с используемыми библиотеками

В данном проекте используются библиотеки Qt и стандартная библиотека C++ (STL), предоставляющие мощные инструменты для разработки графических пользовательских интерфейсов и работы с данными. Qt обеспечивает кроссплатформенное создание интуитивно понятных интерфейсов, а STL предоставляет эффективные алгоритмы и контейнеры для работы с данными.

Особенности использования библиотек и инструментов:

1. Графические пользовательские интерфейсы

Управление виджетами:

Используются классы QMainWindow, QWidget и производные для создания окон и диалогов. Класс MainWindow инкапсулирует функционал работы с турами, отелями, странами, транспортными компаниями и заказами. В окнах реализована связь кнопок с методами через механизмы сигналов и слотов Qt. Это позволяет динамически обрабатывать пользовательские действия и вызывать соответствующие функции.

Использование QTableWidget:

Для отображения данных используются таблицы QTableWidget, которые обеспечивают удобное представление информации в виде строк и столбцов. Таблицы поддерживают сортировку по столбцам, выбор строк и настройку внешнего вида. Для корректной числовой сортировки используется кастомный класс NumericSortItem, который хранит числовое значение отдельно от текстового представления.

2. Диалоговые окна и взаимодействие с пользователем

Модальные диалоги:

Используются диалоговые окна (CountryDialog, HotelDialog, TourDialog, SearchDialog, BookTourDialog) для ввода данных и отображения информации пользователю. Диалоги открываются в модальном режиме через метод exec(), что обеспечивает блокировку основного окна до завершения работы с диалогом. Это концентрирует внимание пользователя на текущей задаче и предотвращает конфликты действий.

Отображение сообщений:

Предупреждения о неверных данных отображаются через QMessageBox::warning, ошибки через QMessageBox::critical, информационные сообщения через QMessageBox::information. Это обеспечивает единообразный интерфейс уведомлений пользователя.

3. Работа с данными и контейнерами

Шаблонный контейнер DataContainer:

Реализован шаблонный контейнер DataContainer для типобезопасного хранения данных различных типов. Контейнер использует QVector для внутреннего хранения и предоставляет итераторы для использования STL-алгоритмов. Это обеспечивает гибкость и эффективность работы с данными.

Использование STL-алгоритмов:

Применяются STL-алгоритмы (std::copy_if, std::sort, std::find_if) для фильтрации и сортировки данных. Это обеспечивает эффективную обработку больших объемов данных и улучшает читаемость кода. Лямбда-функции используются в качестве предикатов для алгоритмов, что делает код компактным и выразительным.

4. Работа с файлами

QFile и QTextStream:

Для работы с файлами используются классы QFile и QTextStream из Qt. QFile обеспечивает доступ к файлам файловой системы, а QTextStream предоставляет удобный интерфейс для чтения и записи текстовых данных. Использование кодировки UTF-8 через QStringConverter::Encoding::Utf8 обеспечивает корректную работу с кириллицей.

Обработка ошибок:

Для обработки ошибок работы с файлами используются классы FileException и StreamFileException, наследующиеся от std::exception. Это обеспечивает единообразную обработку ошибок через механизм исключений. FileException используется для работы с файлами через QFile и QTextStream, а StreamFileException — для работы через стандартные потоки C++ (std::ifstream, std::ofstream).

Работа с потоками C++:

Для демонстрации различных подходов к работе с файлами в проекте реализован класс StreamFileManager, который использует стандартные потоки C++ (std::ifstream, std::ofstream) для сохранения и загрузки данных о странах и заказах. Это демонстрирует перегрузку операторов ввода/вывода (operator<< и operator>>) для классов Country и Order, что обеспечивает удобную работу с потоками.

5. Механизм сигналов и слотов

Интерактивность интерфейса:

В приложении активно используется механизм сигналов и слотов Qt. Например, в MainWindow кнопки связываются с функциями через connect(), что позволяет обрабатывать пользовательские действия. Сигналы и слоты обеспечивают слабую связанность компонентов, что упрощает разработку и поддержку кода.

Обработка событий:

Сигналы от виджетов (например, clicked() от кнопок, currentChanged() от вкладок, sectionClicked() от заголовков таблиц) связываются со слотами для обработки соответствующих событий. Это обеспечивает событийно-ориентированную архитектуру приложения.

6. Работа с датами и временем

QDate и QDateTime:

Для работы с датами используются классы QDate и QDateTime из Qt. QDate предоставляет функциональность для работы с датами (сравнение, вычисление разницы в днях), а QDateTime объединяет дату и время. Метод daysTo() используется для вычисления продолжительности тура в днях.

7. Работа со строками

QString:

Для работы со строками используется класс QString из Qt, который обеспечивает удобную работу с Unicode-строками. Методы contains(), toLower(), split(), trimmed() используются для обработки текстовых данных, таких как названия стран, городов и адресов. Для преобразования между QString и std::string используются методы toStdString() и fromStdString().

8. Работа с сетью

QNetworkAccessManager и QNetworkReply:

Для работы с сетевыми запросами используются классы QNetworkAccessManager и QNetworkReply из модуля Qt Network. В проекте реализована функциональность автоматического обновления курсов валют через сетевые запросы. QNetworkAccessManager отправляет асинхронные HTTP-запросы, а обработка ответов выполняется в слоте, подключенном к сигналу finished() через механизм сигналов и слотов.

QTimer:

Для периодического обновления курсов валют используется класс QTimer. Таймер настраивается на автоматический запуск сетевых запросов через заданные интервалы времени, что обеспечивает актуальность информации о курсах валют без вмешательства пользователя.

9. Работа с коллекциями Qt

QVector и QSet:

В проекте используются контейнеры Qt: QVector для хранения упорядоченных коллекций (например, номеров отелей, расписаний рейсов) и QSet для хранения уникальных элементов (например, целевых городов при поиске транспорта). QSet обеспечивает быструю проверку наличия элемента и автоматическое исключение дубликатов.

QDate методы:

Класс QDate используется не только для хранения дат, но и для их сравнения и валидации через метод isValid(). Метод daysTo() вычисляет разницу в днях между двумя датами, что критично для расчета продолжительности туров и стоимости проживания.

10. Стабильность работы приложения

Обработка исключений:

Для обеспечения стабильности работы приложения используются исключения для обработки ошибок. Исключения перехватываются в соответствующих блоках try-catch, и пользователю отображаются понятные сообщения об ошибках через QMessageBox.

Валидация данных:

Перед выполнением операций выполняется валидация входных данных (проверка на пустые поля, корректность дат, наличие данных в контейнерах). Это предотвращает ошибки и обеспечивает целостность данных. Используются методы isEmpty() для проверки пустоты строк и контейнеров, isValid() для проверки корректности дат.

11. Производительность

Использование итераторов:

Использование итераторов для обхода контейнеров обеспечивает эффективный доступ к элементам. Итераторы поддерживают операции инкремента, декремента и арифметические операции, что позволяет использовать STL-алгоритмы для обработки данных.

Кэширование вычислений:

Стоимость туров вычисляется динамически при каждом обращении, что гарантирует актуальность данных. Однако при отображении в таблице стоимость вычисляется один раз и сохраняется в NumericSortItem для отображения и сортировки.

Эффективная фильтрация:

Для фильтрации данных в таблицах используется механизм скрытия строк через setRowHidden() вместо пересоздания таблицы, что обеспечивает быструю работу фильтров даже с большими объемами данных.

12. Кроссплатформенность

Qt Framework:

Использование Qt Framework обеспечивает кроссплатформенность приложения. Код, написанный с использованием Qt, может быть скомпилирован для различных платформ (Windows, Linux, macOS) без изменений, что упрощает развертывание и поддержку приложения.

13. Особенности многопоточности

Асинхронные сетевые запросы:

QNetworkAccessManager выполняет сетевые запросы асинхронно, не блокируя основной поток выполнения. Это обеспечивает отзывчивость интерфейса даже при выполнении длительных сетевых операций. Результаты запросов обрабатываются в главном потоке через механизм сигналов и слотов.

14. Полиморфизм и наследование

Виртуальные функции:

В проекте активно используется полиморфизм через виртуальные функции. Базовый класс TouristService определяет виртуальные функции getType(), getDescription() и calculateCost(), которые переопределяются в производных классах (Country, Hotel, Room, TransportCompany, Tour). Это позволяет единообразно работать с различными типами туристических услуг через указатели или ссылки на базовый класс.

Перегрузка операторов:

В проекте реализована перегрузка операторов для классов Country и Order. Операторы сравнения (==, !=, <) обеспечивают удобное сравнение объектов. Операторы ввода/вывода в потоки (operator<<, operator>>) обеспечивают удобную сериализацию и десериализацию данных при работе с файлами через стандартные потоки C++.

15. Трехрежимная сортировка таблиц

QHeaderView и сортировка:

В проекте реализована трехрежимная сортировка таблиц: по возрастанию, по убыванию и отмена сортировки (возврат к исходному порядку). Это достигается через обработку сигнала sectionClicked() от заголовков таблиц и управление порядком сортировки через setSortingEnabled(). Для каждого столбца отслеживается текущий режим сортировки, что обеспечивает интуитивно понятное поведение при повторных кликах по заголовку.

16. Паттерн Command для инкапсуляции операций

Action и производные классы:

В проекте реализован паттерн Command через базовый класс Action и производные классы для различных операций (добавление, редактирование, удаление, просмотр информации). Это позволяет инкапсулировать операции в виде объектов, что упрощает управление действиями пользователя и обеспечивает возможность расширения функциональности без изменения основного кода. Все действия хранятся в карте QMap<QString, Action*> и выполняются через единый интерфейс метода execute().


ЗАКЛЮЧЕНИЕ

В ходе выполнения курсовой работы была разработана система управления туристическим агентством, представляющая собой полнофункциональное настольное приложение для автоматизации процессов работы туристического агентства.

Основные результаты работы:

1. Разработана объектно-ориентированная архитектура приложения с использованием паттернов проектирования и принципов ООП. Реализована иерархия классов с базовым абстрактным классом TouristService и производными классами Country, Hotel, Room, TransportCompany и Tour, демонстрирующая принципы наследования и полиморфизма.

2. Реализован шаблонный контейнер DataContainer с поддержкой итераторов, совместимых со стандартной библиотекой C++ (STL). Это обеспечило возможность использования STL-алгоритмов (std::copy_if, std::sort, std::find_if) для эффективной обработки данных.

3. Создан графический интерфейс пользователя с использованием фреймворка Qt, включающий главное окно с вкладками для управления различными типами данных и набор диалоговых окон для ввода и редактирования информации. Реализована трехрежимная сортировка таблиц и система фильтрации данных.

4. Разработана система хранения данных на основе текстовых файлов с поддержкой кодировки UTF-8 для корректной работы с кириллицей. Реализованы два подхода к работе с файлами: через классы Qt (QFile, QTextStream) и через стандартные потоки C++ (std::ifstream, std::ofstream).

5. Реализована функция автоматического формирования туров с расчетом стоимости на основе выбранных услуг. Система автоматически связывает туры с отелями и транспортными компаниями на основе страны назначения и дат поездки.

6. Создана система управления заказами с поддержкой различных статусов обработки и автоматическим расчетом стоимости на основе выбранного тура.

7. Реализован функционал поиска туров по критериям с использованием STL-алгоритмов и лямбда-функций, обеспечивающий гибкую фильтрацию по стране, стоимости и продолжительности.

8. Добавлена функциональность работы с сетью для получения курсов валют через QNetworkAccessManager с асинхронной обработкой запросов.

9. Все туристические маршруты в системе отправляются из города Минск (Беларусь), что соответствует специфике работы туристического агентства.

Разработанная система демонстрирует практическое применение концепций объектно-ориентированного программирования, включая наследование, полиморфизм, инкапсуляцию, шаблоны, перегрузку операторов и обработку исключений. В проекте также реализован паттерн проектирования Command для инкапсуляции операций с данными, что обеспечивает гибкость и расширяемость системы. Использование фреймворка Qt обеспечивает кроссплатформенность приложения и возможность его развертывания на различных операционных системах.

Система может быть использована небольшими туристическими агентствами для автоматизации процессов управления турами и заказами, обеспечивая эффективную работу с данными и снижение вероятности ошибок при ручной обработке информации.

Направления дальнейшего развития:

‒ Интеграция с внешними системами бронирования отелей и транспорта.

‒ Реализация системы отчетности и аналитики для анализа продаж и популярных направлений.

‒ Добавление функциональности работы с платежными системами для онлайн-оплаты туров.

‒ Расширение функционала поиска и фильтрации с использованием более сложных критериев.

‒ Реализация многопользовательского режима работы с разграничением прав доступа.

‒ Добавление возможности экспорта данных в различные форматы (PDF, Excel, CSV).


СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ

1. Stroustrup, B. The C++ Programming Language (4th Edition) / B. Stroustrup. — Addison-Wesley Professional, 2013. — 1376 p.

2. Meyers, S. Effective C++: 55 Specific Ways to Improve Your Programs and Designs (3rd Edition) / S. Meyers. — Addison-Wesley Professional, 2005. — 320 p.

3. Gamma, E. Design Patterns: Elements of Reusable Object-Oriented Software / E. Gamma, R. Helm, R. Johnson, J. Vlissides. — Addison-Wesley Professional, 1994. — 395 p.

4. Blanchette, J. C++ GUI Programming with Qt 4 (2nd Edition) / J. Blanchette, M. Summerfield. — Prentice Hall, 2008. — 752 p.

5. Qt Documentation: Qt 6.10 Reference Documentation [Electronic resource]. — Mode of access: https://doc.qt.io/qt-6/. — Date of access: 16.11.2025.

6. cppreference.com: C++ reference [Electronic resource]. — Mode of access: https://en.cppreference.com/. — Date of access: 16.11.2025.

7. Josuttis, N. M. The C++ Standard Library: A Tutorial and Reference (2nd Edition) / N. M. Josuttis. — Addison-Wesley Professional, 2012. — 1128 p.

8. Sutter, H. Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions / H. Sutter. — Addison-Wesley Professional, 1999. — 240 p.

9. Alexandrescu, A. Modern C++ Design: Generic Programming and Design Patterns Applied / A. Alexandrescu. — Addison-Wesley Professional, 2001. — 352 p.

10. Qt Network Module Documentation [Electronic resource]. — Mode of access: https://doc.qt.io/qt-6/qtnetwork-index.html. — Date of access: 16.11.2025.


ПРИЛОЖЕНИЕ А

Диаграмма классов системы управления туристическим агентством

(Здесь должна быть UML-диаграмма классов, показывающая иерархию наследования TouristService и связи между классами Country, Hotel, Room, TransportCompany, Tour, Order, DataContainer, FileManager, StreamFileManager и MainWindow)


ПРИЛОЖЕНИЕ Б

Блок-схема алгоритма формирования тура с автоматическим расчетом стоимости

(Здесь должна быть блок-схема, иллюстрирующая процесс создания тура от ввода данных до автоматического расчета стоимости и связывания с отелями и транспортными компаниями)


ПРИЛОЖЕНИЕ В

Блок-схема алгоритма поиска туров по критериям

(Здесь должна быть блок-схема, показывающая процесс фильтрации туров с использованием STL-алгоритма std::copy_if и трех режимов фильтрации для каждого критерия)


ПРИЛОЖЕНИЕ Г

Структура файлов данных системы

countries.txt — формат хранения информации о странах:
```
COUNTRIES
[количество записей]
[название страны]
[континент]
[столица]
[валюта]
...
```

hotels.txt — формат хранения информации об отелях:
```
HOTELS
[количество записей]
[название отеля]
[страна]
[количество звезд]
[адрес]
[количество номеров]
  [название номера]
  [тип номера: 0-Single, 1-Double, 2-Suite, 3-Apartment]
  [вместимость]
  [цена за ночь]
  ...
```

transport_companies.txt — формат хранения информации о транспортных компаниях:
```
TRANSPORT_COMPANIES
[количество записей]
[название компании]
[тип транспорта: 0-Airplane, 1-Bus, 2-Train, 3-Ship]
[количество рейсов]
  [город отправления]
  [город прибытия]
  [дата отправления: дд.мм.гггг]
  [дата прибытия: дд.мм.гггг]
  [стоимость]
  [доступные места]
  ...
```

tours.txt — формат хранения информации о турах:
```
TOURS
[количество записей]
[название тура]
[страна]
[дата начала: дд.мм.гггг]
[дата окончания: дд.мм.гггг]
[данные отеля...]
[данные транспортной компании...]
```

orders.txt — формат хранения информации о заказах:
```
ORDERS
[количество записей]
[имя клиента]
[телефон клиента]
[дата заказа: дд.мм.гггг чч:мм:сс]
[статус]
[данные тура...]
```

